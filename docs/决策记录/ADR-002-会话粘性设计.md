# ADR-002: 会话粘性设计决策

> 日期：2025-12-17（更新于 2025-12-19）
> 状态：已采纳
> 决策者：开发团队

---

## 背景

系统支持多种 AI 平台账户（OpenAI、Claude、OpenAI Responses 等），需要实现会话粘性功能，确保同一会话的请求始终路由到同一后端账户，保持对话上下文的连续性。

## 决策点

### 1. 会话标识方式

**问题**：如何标识一个会话？

**选项**：
- A. 客户端传递 Session ID
- B. 根据 API Key ID 生成
- C. 根据用户 ID 生成
- D. 混合方式（不同场景不同策略）

**决策**：选择 D - 混合方式

**理由**：
- OpenAI/Claude 代理：使用客户端传递的 Session ID（支持多会话）
- OpenAI Responses API：使用 `apikey:{apiKeyID}` 格式（同一 Key 绑定同一账户）
- 不同场景有不同的粘性需求

**实现**：
```go
// OpenAI/Claude 代理 - 使用客户端 Session ID
sessionID := c.GetHeader("X-Session-ID")

// OpenAI Responses API - 使用 API Key ID
sessionID := fmt.Sprintf("apikey:%d", apiKeyID)
```

---

### 2. 会话存储方式

**问题**：会话绑定信息存储在哪里？

**选项**：
- A. 内存（单机）
- B. Redis（分布式）
- C. MySQL（持久化）

**决策**：选择 B - Redis

**理由**：
- 支持分布式部署，多实例共享会话
- 天然支持 TTL 过期
- 高性能读写
- 无需持久化（会话是临时数据）

**Redis Key 设计**：
```
session:binding:{sessionID}  -> Hash (account_id, platform, model, user_id, api_key_id, created_at)
session:account:{accountID}  -> Set (sessionID1, sessionID2, ...)
```

---

### 3. 会话 TTL 策略

**问题**：会话绑定应该保持多长时间？

**选项**：
- A. 固定 TTL（如 1 小时）
- B. 滑动 TTL（每次访问刷新）
- C. 智能续期（低于阈值时才续期）

**决策**：选择 C - 智能续期

**理由**：
- 固定 TTL：活跃会话可能中断
- 滑动 TTL：每次请求都续期，Redis 压力大
- 智能续期：剩余时间 < 阈值时才续期，平衡两者

**实现**：
```go
// 默认配置
session_ttl = 60 分钟          // 会话总时长
session_renewal_ttl = 14 分钟  // 续期阈值

// 逻辑
if remainingTTL < session_renewal_ttl {
    refreshTTL(session_ttl)
}
```

---

### 4. 账户不可用时的处理

**问题**：绑定的账户变为不可用（禁用/限流）时如何处理？

**选项**：
- A. 返回错误，要求客户端重试
- B. 自动切换到其他账户
- C. 移除绑定，下次请求重新选择

**决策**：选择 C - 移除绑定重新选择

**理由**：
- 对客户端透明，无需感知账户切换
- 自动容错，提高可用性
- 新会话可能绑定到更好的账户

**实现**：
```go
if binding != nil {
    account := findAccount(binding.AccountID)
    if account == nil || !account.Enabled || account.Status != Valid {
        removeBinding(sessionID)
        // 继续正常选择流程
    }
}
```

---

### 5. 调度方法设计

**问题**：如何组织支持会话粘性的调度方法？

**选项**：
- A. 修改现有方法添加 session 参数
- B. 创建新的 WithSession 方法
- C. 统一使用一个方法，参数可选

**决策**：选择 B - 创建新的 WithSession 方法

**理由**：
- 保持现有方法兼容性
- 方法职责明确
- 调用方明确知道是否使用会话粘性

**方法列表**：
| 方法 | 说明 | 使用场景 |
|------|------|----------|
| `SelectAccount()` | 按模型选择，无会话 | 简单场景 |
| `SelectAccountWithSession()` | 按模型选择，支持会话 | OpenAI/Claude 代理 |
| `SelectAccountByType()` | 按类型选择，无会话 | 简单场景 |
| `SelectAccountByTypeWithSession()` | 按类型选择，支持会话 | 单类型场景 |
| `SelectAccountByTypesWithSession()` | 按多类型选择，支持会话 | OpenAI Responses API（支持 openai-responses 和 openai 类型） |

> **2025-12-19 更新**：新增 `SelectAccountByTypesWithSession()` 方法，支持从多个账户类型中选择，用于 OpenAI Responses API 同时支持 ChatGPT 官方账户和第三方 OpenAI API。

---

## 影响

1. **性能**：每次请求多一次 Redis 查询，但 Redis 性能足够
2. **可靠性**：依赖 Redis 可用性，Redis 不可用时降级为无粘性
3. **扩展性**：支持水平扩展，多实例共享会话状态

---

## 相关文档

- [M3-代理转发模块设计](../模块设计/M3-代理转发.md)
- [M7-缓存管理模块设计](../模块设计/M7-缓存管理.md)
- [功能模块索引 - 缓存管理](../功能模块索引.md#9-缓存管理)
