# 开发日志 2025-12-23

## 完成的工作

### 1. HTTP 客户端连接池优化

**需求描述**：
优化 HTTP 客户端性能，减少每次请求创建新客户端的开销，复用连接池提高并发性能。

**问题分析**：
原有实现每次请求都创建新的 `*http.Client`，存在以下问题：
1. 连接无法复用，每次请求都建立新 TCP 连接
2. 代理客户端重复创建，浪费内存和时间
3. 高并发场景下性能瓶颈明显

**优化方案**：

1. **全局预配置客户端**：
   - `defaultHTTPClient`: 普通请求客户端（120秒超时）
   - `defaultStreamClient`: 流式请求客户端（600秒超时）

2. **代理客户端缓存**：
   - 使用 `proxyClientCache` map 缓存代理客户端
   - 使用 `sync.RWMutex` 保证并发安全
   - 缓存键区分普通/流式客户端

3. **连接池参数配置**：
   - `MaxIdleConns: 100` - 最大空闲连接数
   - `MaxIdleConnsPerHost: 20` - 每主机最大空闲连接
   - `IdleConnTimeout: 90s` - 空闲连接超时

**修改文件**：

`internal/proxy/adapter/http_client.go`:

新增全局变量（第28-64行）：
```go
var (
    // 默认客户端（无代理）- 普通请求
    defaultHTTPClient = &http.Client{
        Timeout: 120 * time.Second,
        Transport: &http.Transport{
            MaxIdleConns:        100,
            MaxIdleConnsPerHost: 20,
            IdleConnTimeout:     90 * time.Second,
            DisableCompression:  false,
            DialContext: (&net.Dialer{
                Timeout:   30 * time.Second,
                KeepAlive: 30 * time.Second,
            }).DialContext,
        },
    }

    // 默认客户端（无代理）- 流式请求
    defaultStreamClient = &http.Client{
        Timeout: 600 * time.Second,
        Transport: &http.Transport{
            MaxIdleConns:          100,
            MaxIdleConnsPerHost:   20,
            IdleConnTimeout:       120 * time.Second,
            DisableCompression:    true,   // 禁用压缩，避免流式解析问题
            ForceAttemptHTTP2:     false,  // 禁用 HTTP/2
            ResponseHeaderTimeout: 0,      // 无响应头超时
        },
    }

    // 代理客户端缓存
    proxyClientCache     = make(map[string]*http.Client)
    proxyClientCacheLock sync.RWMutex
)
```

新增函数：
- `getOrCreateProxyClient()` (第88-218行) - 获取或创建代理客户端（带缓存）
- `ClearProxyClientCache()` (第567-579行) - 清理指定代理的客户端缓存
- `ClearAllProxyClientCache()` (第581-591行) - 清理所有代理客户端缓存
- `GetProxyClientCacheStats()` (第593-614行) - 获取代理客户端缓存统计

修改函数：
- `GetHTTPClient()` (第66-75行) - 使用全局客户端或缓存的代理客户端
- `GetStreamHTTPClient()` (第77-86行) - 使用全局流式客户端或缓存的代理客户端

**性能提升**：
- 连接复用：减少 TCP 握手开销
- 内存优化：避免重复创建客户端对象
- 并发改进：线程安全的缓存机制

---

## 技术要点

### 1. 连接池配置说明

| 参数 | 值 | 说明 |
|------|-----|------|
| `MaxIdleConns` | 100 | 全局最大空闲连接数 |
| `MaxIdleConnsPerHost` | 20 | 每个主机最大空闲连接 |
| `IdleConnTimeout` | 90s | 空闲连接超时时间 |
| `DialContext.Timeout` | 30s | 连接建立超时 |
| `DialContext.KeepAlive` | 30s | TCP KeepAlive 间隔 |

### 2. 流式客户端特殊配置

| 参数 | 值 | 说明 |
|------|-----|------|
| `DisableCompression` | true | 禁用压缩，避免流式解析问题 |
| `ForceAttemptHTTP2` | false | 禁用 HTTP/2，避免多路复用问题 |
| `ResponseHeaderTimeout` | 0 | 无响应头超时，支持长时间流式响应 |
| `Timeout` | 600s | 10分钟总超时 |

### 3. 缓存键设计

```
普通客户端: "socks5://proxy.example.com:1080"
流式客户端: "stream:socks5://proxy.example.com:1080"
```

### 4. 线程安全

使用 `sync.RWMutex` 实现读写锁：
- 读取缓存使用 `RLock()` 允许并发读
- 写入缓存使用 `Lock()` 独占写

---

## 文档更新

- [x] 更新 `docs/代码索引.md` - 添加变更记录
- [x] 更新 `docs/功能模块索引.md` - 添加 HTTP 客户端小节
- [x] 更新 `docs/README.md` - 文档更新记录

---

## 备注

- 原文件已备份为 `http_client.go.bak`
- 参考了 `docs/参考项目/claude-relay-src/handlers/relay.go` 中的实现模式
