# M7 缓存管理模块设计

## 模块概述

缓存管理模块负责管理内存缓存中的各类数据，包括粘性会话、临时不可用标记、并发控制等。支持通过 Web 界面进行可视化管理和手动清理。

## 核心功能

### 1. 粘性会话管理
- 会话与账户绑定，确保同一会话的请求路由到同一账户
- 支持智能 TTL 续期（剩余时间不足阈值时自动续期）
- 支持按账户维度聚合查看会话

### 2. 临时不可用标记
- 账户出现 5xx 错误时自动标记为临时不可用
- 支持自定义 TTL 和不可用原因
- 调度器在选择账户时跳过不可用账户

### 3. 并发控制
- 基于内存的并发计数（atomic.Int64）
- 支持按账户设置并发限制
- 防止单个账户被过度使用

### 4. 缓存统计与清理
- 实时统计各类缓存数量
- 支持按类型清理缓存
- 支持清理指定用户/账户的缓存

## 内存缓存结构

```go
// SessionStore - 会话绑定存储
type SessionStore struct {
    sessions sync.Map  // sessionID -> *SessionBinding
}

// ConcurrencyManager - 并发计数管理
type ConcurrencyManager struct {
    counters sync.Map  // accountID/userID -> *ConcurrencyEntry
}

// UnavailableMarker - 不可用标记
type UnavailableMarker struct {
    marks sync.Map  // accountID -> *UnavailableMark
}
```

## TTL 配置

| 缓存类型 | 配置项 | 默认值 | 说明 |
|---------|--------|--------|------|
| 会话绑定 | session_ttl | 60 分钟 | 智能续期阈值 14 分钟 |
| 不可用标记 | unavailable_ttl | 5 分钟 | 可通过 API 自定义 |
| 并发计数 | concurrency_ttl | 5 分钟 | 防止计数泄漏 |

## 数据结构

### SessionBinding 会话绑定

```go
type SessionBinding struct {
    SessionID  string    `json:"session_id"`
    AccountID  uint      `json:"account_id"`
    Platform   string    `json:"platform"`
    Model      string    `json:"model,omitempty"`
    UserID     uint      `json:"user_id"`
    APIKeyID   uint      `json:"api_key_id"`
    ClientIP   string    `json:"client_ip"`
    BoundAt    time.Time `json:"bound_at"`
    LastUsedAt time.Time `json:"last_used_at"`
    ExpiresAt  time.Time `json:"expires_at"`
}
```

### UnavailableMark 不可用标记

```go
type UnavailableMark struct {
    AccountID  uint      `json:"account_id"`
    Reason     string    `json:"reason"`
    MarkedAt   time.Time `json:"marked_at"`
    ExpiresAt  time.Time `json:"expires_at"`
}
```

### CacheStats 缓存统计

```go
type CacheStats struct {
    SessionCount             int64 `json:"session_count"`
    AccountConcurrencyCount  int64 `json:"account_concurrency_count"`
    UserConcurrencyCount     int64 `json:"user_concurrency_count"`
    UnavailableCount         int64 `json:"unavailable_count"`
}
```

## API 接口设计

### 缓存管理接口（管理员）

#### 获取缓存配置
```
GET /api/admin/cache/config

Response:
{
    "session_ttl": 60,
    "session_renewal_ttl": 14,
    "unavailable_ttl": 5,
    "concurrency_ttl": 5,
    "default_concurrency_max": 5
}
```

#### 更新缓存配置
```
PUT /api/admin/cache/config
Content-Type: application/json

{
    "session_ttl": 60,
    "session_renewal_ttl": 14,
    "unavailable_ttl": 5,
    "concurrency_ttl": 5,
    "default_concurrency_max": 5
}
```

#### 获取账号缓存列表（聚合视图）
```
GET /api/admin/cache/accounts

Response:
{
    "accounts": [
        {
            "account_id": 1,
            "account_name": "Claude-1",
            "session_count": 5,
            "current_concurrency": 3,
            "is_unavailable": false
        }
    ]
}
```

#### 获取用户缓存列表（聚合视图）
```
GET /api/admin/cache/users

Response:
{
    "users": [
        {
            "user_id": 1,
            "username": "admin",
            "session_count": 3,
            "current_concurrency": 2
        }
    ]
}
```

#### 列出所有会话绑定
```
GET /api/admin/cache/sessions

Response:
{
    "sessions": [
        {
            "session_id": "apikey:1",
            "account_id": 1,
            "platform": "claude",
            "user_id": 1,
            "api_key_id": 1,
            "bound_at": "2025-12-09T10:00:00Z",
            "expires_at": "2025-12-09T11:00:00Z"
        }
    ],
    "total": 100
}
```

#### 移除会话绑定
```
DELETE /api/admin/cache/sessions/:sessionId

Response:
{
    "message": "session removed"
}
```

#### 清理缓存
```
POST /api/admin/cache/clear
Content-Type: application/json

{
    "type": "sessions"  // sessions, unavailable, concurrency, all
}

Response:
{
    "type": "sessions",
    "deleted_count": 50
}
```

### 账户缓存管理接口

#### 获取账户并发信息
```
GET /api/admin/accounts/:id/cache/concurrency

Response:
{
    "account_id": 1,
    "current": 3,
    "limit": 5
}
```

#### 重置账户并发计数
```
DELETE /api/admin/accounts/:id/cache/concurrency

Response:
{
    "message": "concurrency reset"
}
```

### 用户缓存管理接口

#### 获取用户并发信息
```
GET /api/admin/users/:id/concurrency

Response:
{
    "user_id": 1,
    "current": 2,
    "limit": 10
}
```

#### 重置用户并发计数
```
DELETE /api/admin/users/:id/concurrency

Response:
{
    "message": "concurrency reset"
}
```

## 代码结构

```
internal/
├── cache/
│   └── memory.go          # 内存缓存实现
│       ├── SessionStore
│       ├── ConcurrencyManager
│       └── UnavailableMarker
├── service/
│   └── cache.go           # 缓存管理服务
│       ├── SessionBinding 管理
│       ├── 临时不可用标记
│       ├── 并发控制
│       └── 缓存统计
└── handler/
    ├── cache.go           # 缓存管理处理器
    └── routes.go          # 路由注册

web/src/
├── views/
│   └── Cache.vue          # 缓存管理页面
├── api/
│   └── index.js           # API 接口
├── router/
│   └── index.js           # 路由配置
└── layouts/
    └── MainLayout.vue     # 菜单配置
```

## 前端页面

### 缓存管理页面 (Cache.vue)

**功能区域**：

1. **缓存配置**
   - 会话 TTL
   - 会话续期阈值
   - 不可用标记 TTL
   - 并发计数 TTL
   - 默认最大并发数

2. **Tab 页面**
   - 账号缓存：聚合视图，显示每个账号的会话数、并发数、不可用状态
   - 用户缓存：聚合视图，显示每个用户的会话数、并发数
   - 会话列表：详细会话绑定列表

3. **操作功能**
   - 清除单个会话
   - 重置账号并发
   - 重置用户并发
   - 批量清理缓存

## 智能续期机制

```go
// 获取会话时检查是否需要续期
func (s *CacheService) GetSessionBinding(ctx context.Context, sessionID string) (*SessionBinding, error) {
    binding := sessionStore.Get(sessionID)
    if binding == nil {
        return nil, nil
    }

    // 检查是否需要续期
    remaining := time.Until(binding.ExpiresAt)
    if remaining > 0 && remaining < sessionRenewalTTL {
        // 剩余时间不足阈值，自动续期
        binding.ExpiresAt = time.Now().Add(sessionTTL)
        sessionStore.Set(sessionID, binding)
    }

    return binding, nil
}
```

## 并发控制流程

```
请求到达
    ↓
AcquireConcurrency(accountID)
    ↓
atomic.AddInt64(&counter, 1)
    ↓
检查是否超过限制
    ↓
├─ 未超限 → 处理请求 → ReleaseConcurrency → atomic.AddInt64(&counter, -1)
└─ 超限 → 回退 → 返回拒绝/选择其他账户
```

## 依赖关系

```
CacheHandler
    └── CacheService
        └── memory.go (SessionStore, ConcurrencyManager, UnavailableMarker)

ProxyHandler (调度器)
    └── CacheService
        ├── GetSessionBinding (获取会话绑定)
        ├── SetSessionBinding (设置会话绑定)
        ├── IsAccountUnavailable (检查可用性)
        ├── MarkAccountUnavailable (标记不可用)
        ├── AcquireConcurrency (获取并发槽)
        └── ReleaseConcurrency (释放并发槽)
```

## 安全考虑

1. **权限控制**：所有缓存管理接口需要管理员权限
2. **危险操作确认**：清理全部缓存需要二次确认
3. **并发限制范围**：限制在 1-100 之间，防止配置错误

## 性能优化

1. **sync.Map**：使用 sync.Map 实现线程安全的并发访问
2. **atomic 操作**：并发计数使用 atomic.Int64 保证原子性
3. **智能续期**：仅在必要时续期，减少写操作
4. **后台清理**：定期清理过期数据，避免内存泄漏

## 注意事项

1. **服务重启**：内存缓存在服务重启后会丢失，会话绑定需要重新建立
2. **单机限制**：内存缓存不支持分布式，多实例部署时各实例缓存独立
3. **内存监控**：需要关注内存使用情况，避免缓存过多导致 OOM
