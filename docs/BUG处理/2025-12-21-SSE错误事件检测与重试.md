# SSE 错误事件检测与重试机制

> 修复日期：2025-12-21
> 类型：BUG修复
> 严重程度：高（导致流式请求断流）

## 问题描述

Claude 流式请求出现断流，日志显示：
```
Claude Stream 行数异常少 | 总行数: 3 | InputTokens: 0 | OutputTokens: 0
```

流只传输了 3 行就结束，没有获取到任何 token 统计。

## 原因分析

通过添加调试日志捕获流内容，发现：

```
event: error
data: {"type":"error","error":{"type":"permission_error","message":"Permission denied"}}

```

**根本原因**：
1. 上游服务返回 HTTP 200 状态码（表示连接成功）
2. 但实际发送的是 SSE 错误事件，而非正常的消息内容
3. 原代码没有检测 SSE 事件类型，直接透传给客户端
4. 客户端收到错误事件后流异常结束

**为什么原来的重试机制没生效**：
- 原 `isConnectionError()` 只检测连接级别错误（如 timeout、connection refused）
- SSE 错误事件是在连接成功后发生的，不属于连接错误
- 因此没有触发重试

## 解决方案

### 1. 缓冲首个事件行

在 `SendStream` 方法中，不立即写入 `event:` 行，而是缓冲等待 `data:` 行：

**文件**: `internal/proxy/adapter/claude.go`

```go
// 新增变量
var debugLines []string      // 记录前几行用于调试
var lastEventType string     // 记录上一个 event 类型
var firstEventChecked bool   // 是否已检查首个事件
var pendingEventLine []byte  // 缓冲的 event 行

// 检测 event 类型
if strings.HasPrefix(lineStr, "event: ") {
    lastEventType = strings.TrimPrefix(lineStr, "event: ")
    if !firstEventChecked {
        pendingEventLine = make([]byte, len(line))
        copy(pendingEventLine, line)
        continue // 不立即写入，等待 data 行
    }
}
```

### 2. 检测首个事件是否为错误

如果首个事件是 `error` 类型，解析错误内容并返回错误（触发重试）：

```go
if strings.HasPrefix(lineStr, "data: ") {
    dataStr := strings.TrimPrefix(lineStr, "data: ")

    // 检测首个事件是否为错误
    if !firstEventChecked && lastEventType == "error" {
        var errEvent struct {
            Type  string `json:"type"`
            Error struct {
                Type    string `json:"type"`
                Message string `json:"message"`
            } `json:"error"`
        }
        if err := json.Unmarshal([]byte(dataStr), &errEvent); err == nil && errEvent.Type == "error" {
            log.Error("Claude Stream 首个事件为错误 | Type: %s | Message: %s | AccountID: %d",
                errEvent.Error.Type, errEvent.Error.Message, account.ID)
            // 不写入客户端，直接返回错误以触发重试
            return result, NewUpstreamError(500, fmt.Sprintf("%s: %s", errEvent.Error.Type, errEvent.Error.Message))
        }
    }

    // 首个事件检查完毕，写入缓冲的 event 行
    if !firstEventChecked && len(pendingEventLine) > 0 {
        writer.Write(pendingEventLine)
        writer.Write([]byte("\n"))
    }
    firstEventChecked = true
}
```

### 3. 添加 SSE 错误类型到可重试列表

**文件**: `internal/proxy/scheduler/retry.go`

在 `isConnectionError()` 方法中添加 SSE 错误类型：

```go
// SSE 首个事件为错误（尚未向客户端写入数据，可安全重试）
sseRetryableErrors := []string{
    "permission_error",
    "authentication_error",
    "overloaded_error",
    "rate_limit_error",
    "api_error",
}

for _, sseErr := range sseRetryableErrors {
    if strings.Contains(errStr, sseErr) {
        return true
    }
}
```

## 修改文件清单

| 文件 | 修改内容 |
|------|----------|
| `internal/proxy/adapter/claude.go` | 第220-320行：SSE 错误检测逻辑 |
| `internal/proxy/scheduler/retry.go` | 第480-493行：添加 SSE 可重试错误类型 |

## 调试日志

新增以下日志便于排查：

| 日志级别 | 内容 | 触发条件 |
|----------|------|----------|
| WARN | `Claude Stream 行数异常少 \| 总行数: %d \| 内容: %v` | 流行数 <= 10 |
| ERROR | `Claude Stream 首个事件为错误 \| Type: %s \| Message: %s` | 检测到 SSE 错误事件 |

## 验证方法

1. 观察日志是否出现 `Claude Stream 首个事件为错误` 日志
2. 确认重试机制是否触发（应看到选择新账户的日志）
3. 确认客户端是否收到完整响应

## 已知限制

1. **单账户场景**：如果只有一个账户可用，重试时无法切换到其他账户，仍会失败
2. **持续性错误**：如果上游服务持续返回 `permission_error`，所有重试都会失败
3. **OAuth Token 问题**：`permission_error` 通常表示认证问题，需要检查账户的 OAuth Token 是否有效

## 相关文档

- [代码索引](../代码索引.md) - 变更记录
- [开发日志/2025-12-21](../开发日志/2025-12-21.md) - 完整开发记录
