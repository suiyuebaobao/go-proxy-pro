# Go-AIProxy 代码索引

> 最后更新：2025-12-27
> 本文档提供项目代码结构的完整索引，便于快速定位代码位置

---

## 项目结构概览

```
go-aiproxy/
├── cmd/server/           # 程序入口
├── configs/              # 配置文件
├── internal/             # 内部代码（核心业务逻辑）
│   ├── config/          # 配置加载
│   ├── handler/         # HTTP 处理器（API 接口）
│   ├── middleware/      # 中间件
│   ├── model/           # 数据模型
│   ├── proxy/           # 代理转发核心
│   ├── repository/      # 数据访问层
│   └── service/         # 业务服务层
├── pkg/                  # 公共工具包
├── web/                  # 前端项目 (Vue 3)
└── docs/                 # 项目文档
```

---

## 后端代码索引

### 1. 程序入口
| 文件 | 说明 |
|------|------|
| `cmd/server/main.go` | 程序入口，初始化配置、数据库、路由 |

### 2. 配置模块
| 文件 | 说明 |
|------|------|
| `internal/config/config.go` | 配置结构定义和加载 |
| `configs/config.yaml` | 配置文件模板 |

### 3. HTTP 处理器 (internal/handler/)
| 文件 | 说明 | 主要接口 |
|------|------|----------|
| `routes.go` | 路由注册 | 所有路由定义 |
| `user.go` | 用户管理 | 登录、注册、用户CRUD |
| `account.go` | 账户管理 | 10种AI平台账户管理 |
| `api_key.go` | API Key管理 | 密钥生成、验证、管理 |
| `package.go` | 套餐管理 | 套餐模板、用户套餐 |
| `ai_model.go` | 模型管理 | AI模型CRUD |
| `proxy.go` | 代理转发 | OpenAI/Claude兼容接口 |
| `oauth.go` | OAuth认证 | Claude CCR授权流程 |
| `usage.go` | 使用统计 | 用户使用量查询 |
| `request_log.go` | 请求日志 | 日志查询接口 |
| `request_logger.go` | 日志记录 | 请求日志记录逻辑 |
| `cache.go` | 缓存管理 | 会话/并发/不可用标记管理 |
| `config.go` | 系统配置 | 系统配置管理 |
| `proxy_config.go` | 代理配置 | 代理服务器配置管理 |
| `operation_log.go` | 操作日志 | 管理操作审计日志 |
| `system_log.go` | 系统日志 | 服务器日志文件查看 |
| `static.go` | 静态文件 | 前端静态资源服务 |
| `openai_responses.go` | OpenAI Responses | `/responses` 接口转发（Codex） |

### 4. 中间件 (internal/middleware/)
| 文件 | 说明 |
|------|------|
| `jwt.go` | JWT认证中间件 |
| `api_key.go` | API Key认证中间件 |
| `cors.go` | 跨域处理中间件 |
| `logger.go` | 请求日志中间件 |
| `recovery.go` | 错误恢复中间件 |
| `user_concurrency.go` | 用户并发控制中间件 |
| `operation_logger.go` | 操作日志中间件 |

### 5. 数据模型 (internal/model/)
| 文件 | 说明 | 主要结构体 |
|------|------|-----------|
| `user.go` | 用户模型 | User |
| `account.go` | 账户模型 | Account, AccountGroup |
| `api_key.go` | API Key模型 | APIKey |
| `package.go` | 套餐模型 | Package, UserPackage |
| `ai_model.go` | AI模型定义 | AIModel, DefaultModels |
| `request_log.go` | 请求日志模型 | RequestLog |
| `usage_record.go` | 使用记录模型 | UsageRecord |
| `daily_usage.go` | 日使用统计 | DailyUsage |
| `system_config.go` | 系统配置模型 | SystemConfig |
| `proxy_config.go` | 代理配置模型 | ProxyConfig |
| `operation_log.go` | 操作日志模型 | OperationLog |
| `cache.go` | 缓存相关模型 | UnavailableAccount |

### 6. 数据访问层 (internal/repository/)
| 文件 | 说明 |
|------|------|
| `mysql.go` | MySQL连接初始化 |
| `migrate.go` | 数据库迁移 |
| `user.go` | 用户数据访问 |
| `account.go` | 账户数据访问 |
| `api_key.go` | API Key数据访问 |
| `package.go` | 套餐数据访问 |
| `ai_model.go` | AI模型数据访问 |
| `request_log.go` | 请求日志数据访问 |
| `usage_record.go` | 使用记录数据访问 |
| `daily_usage.go` | 日使用统计数据访问 |
| `system_config.go` | 系统配置数据访问 |
| `proxy_config.go` | 代理配置数据访问 |
| `operation_log.go` | 操作日志数据访问 |

### 7. 业务服务层 (internal/service/)
| 文件 | 说明 | 详细文档 |
|------|------|----------|
| `user.go` | 用户业务逻辑 | |
| `account.go` | 账户业务逻辑（含调度器刷新） | |
| `api_key.go` | API Key业务逻辑 | |
| `usage.go` | 使用统计服务（直接写MySQL） | [M9-服务层设计](模块设计/M9-服务层设计.md) |
| `pricing.go` | 计费定价服务 | |
| `cache.go` | 缓存服务（会话绑定/并发控制/不可用标记） | |
| `config.go` | 配置服务（运行时配置） | |
| `health_check.go` | 账号健康检查服务（分级检测策略） | |

**健康检查服务详情** (`health_check.go`):
| 方法 | 说明 |
|------|------|
| `Start()` | 启动服务（两个检测循环） |
| `normalAccountLoop()` | 正常账号定期检查循环 |
| `problemAccountLoop()` | 问题账号探测循环（每分钟） |
| `handleRateLimitedAccount()` | 限流账号处理（指数退避探测） |
| `handleTokenExpiredAccount()` | Token 过期账号处理 |
| `handleSuspendedAccount()` | 疑似封号账号处理（确认机制） |
| `handleBannedAccount()` | 封号账号复活检测 |
| `TriggerSingleCheck()` | 手动触发单个账号检测 |
| `ForceRecover()` | 强制恢复账号 |
| `RefreshToken()` | 刷新账号 Token |

### 8. 代理转发核心 (internal/proxy/)

#### 8.1 适配器 (adapter/)
| 文件 | 说明 |
|------|------|
| `adapter.go` | 适配器接口定义 |
| `openai.go` | OpenAI适配器 |
| `claude.go` | Claude Official适配器 |
| `claude_ccr.go` | Claude CCR (OAuth)适配器 |
| `azure.go` | Azure OpenAI适配器 |
| `gemini.go` | Google Gemini适配器 |
| `bedrock.go` | AWS Bedrock适配器 |
| `openai_responses.go` | OpenAI Responses适配器（Codex） |
| `http_client.go` | HTTP 客户端（含 Chrome TLS 支持） |
| `converter.go` | 格式转换器 |

#### 8.2 调度器 (scheduler/)
| 文件 | 说明 |
|------|------|
| `scheduler.go` | 账户调度器（负载均衡、多类型选择、会话粘性） |
| `session.go` | 会话管理（会话粘性） |
| `retry.go` | 重试机制 |
| `token.go` | Token刷新管理 |

**调度器主要方法**：
| 方法 | 说明 |
|------|------|
| `SelectAccount()` | 按模型选择账户 |
| `SelectAccountWithSession()` | 按模型选择账户（支持会话粘性） |
| `SelectAccountByType()` | 按账户类型选择 |
| `SelectAccountByTypeWithSession()` | 按账户类型选择（支持会话粘性） |
| `SelectAccountByTypesWithSession()` | 按多个账户类型选择（支持会话粘性） |

### 9. 公共工具包 (pkg/)
| 文件 | 说明 |
|------|------|
| `logger/logger.go` | 日志工具 |
| `response/response.go` | 统一响应格式 |
| `utils/jwt.go` | JWT工具 |

---

## 前端代码索引

### 1. 入口和配置
| 文件 | 说明 |
|------|------|
| `web/src/main.js` | Vue应用入口 |
| `web/src/App.vue` | 根组件 |
| `web/src/router/index.js` | 路由配置 |
| `web/src/stores/user.js` | 用户状态管理 (Pinia) |
| `web/src/api/index.js` | API封装 |

### 2. 布局组件
| 文件 | 说明 |
|------|------|
| `layouts/MainLayout.vue` | 主布局（侧边栏+顶栏） |

### 3. 页面视图 (views/)
| 文件 | 说明 | 对应模块 |
|------|------|----------|
| `Home.vue` | 首页（动态效果、API文档、教程） | - |
| `Login.vue` | 登录页面 | M1 |
| `Dashboard.vue` | 仪表盘 | - |
| `Users.vue` | 用户管理（含额度余额/订阅日余额列） | M1 |
| `Accounts.vue` | 账户管理（含限流恢复倒计时） | M2 |
| `AccountLoad.vue` | 账户负载统计 | M2 |
| `APIKeys.vue` | API Key管理 | M4 |
| `Models.vue` | 模型管理 | M5 |
| `Packages.vue` | 套餐管理 | M8 |
| `Usage.vue` | 使用统计 | M6 |
| `RequestLogs.vue` | 请求日志 | M3 |
| `ProxyTest.vue` | 代理测试 | M3 |
| `Cache.vue` | 缓存管理（账号/用户聚合视图） | M7 |
| `OperationLogs.vue` | 操作日志 | - |
| `Proxies.vue` | 代理配置管理 | - |
| `Settings.vue` | 系统设置 | - |
| `Profile.vue` | 个人设置 | M1 |
| `ClientFilter.vue` | 客户端过滤 | M11 |
| `SystemMonitor.vue` | 系统监控 | M12 |
| `SystemLogs.vue` | 系统日志 | M13 |
| `ErrorMessages.vue` | 错误消息配置 | - |

### 4. 公共组件 (components/)
| 文件 | 说明 |
|------|------|
| `AccountForm.vue` | 账户表单（动态字段） |
| `OAuthFlow.vue` | OAuth授权流程组件 |
| `ProxyConfig.vue` | 代理配置组件 |

---

## 关键代码位置快速索引

### 用户管理
- 用户模型: `internal/model/user.go`
- 用户API: `internal/handler/user.go`
- 用户服务: `internal/service/user.go`
- 用户Repository: `internal/repository/user.go`
- 用户列表带余额: `internal/service/user.go:ListWithKeyBalances()`
- 用户Key余额查询: `internal/repository/user.go:GetUserKeyBalances()`

### 账户管理
- 账户模型: `internal/model/account.go`
- 账户API: `internal/handler/account.go`
- 账户Repository: `internal/repository/account.go`
- 账户调度器: `internal/proxy/scheduler/scheduler.go`
- 限流标记: `internal/proxy/scheduler/scheduler.go:MarkAccountErrorWithReset()`
- 限流恢复时间字段: `internal/model/account.go:RateLimitResetAt`

### 认证相关
- JWT生成/验证: `pkg/utils/jwt.go`
- JWT中间件: `internal/middleware/jwt.go`
- API Key验证: `internal/middleware/api_key.go`
- 用户登录: `internal/handler/user.go:Login()`

### 套餐系统
- 套餐模型: `internal/model/package.go`
- 额度检查: `internal/model/package.go:CanUse()`
- 周期重置: `internal/model/package.go:ResetPeriodUsageIfNeeded()`
- 套餐API: `internal/handler/package.go`

### 代理转发
- 代理入口: `internal/handler/proxy.go`
- 适配器接口: `internal/proxy/adapter/adapter.go`
- 账户调度: `internal/proxy/scheduler/scheduler.go`
- 格式转换: `internal/proxy/adapter/converter.go`

### 计费统计
- 定价服务: `internal/service/pricing.go`
- 使用统计: `internal/service/usage.go`
- 使用量API: `internal/handler/usage.go`

### OpenAI Responses (Codex)
- Handler: `internal/handler/openai_responses.go`
- 适配器: `internal/proxy/adapter/openai_responses.go`
- 流式处理: `internal/handler/openai_responses.go:handleStreamResponse()`
- Usage解析: `internal/handler/openai_responses.go:parseSSEForUsage()`
- 多类型账户选择: `internal/proxy/scheduler/scheduler.go:SelectAccountByTypesWithSession()`
- 会话哈希生成: `internal/handler/openai_responses.go:generateSessionHash()`
- 支持账户类型: `openai-responses`（ChatGPT官方）, `openai`（第三方API）

### 数据库
- 数据库连接: `internal/repository/mysql.go`
- 自动迁移: `internal/repository/migrate.go`
- MySQL连接: `internal/repository/mysql.go`

---

## 定时任务索引

| 任务名称 | 文件位置 | 执行间隔 | 说明 |
|----------|----------|----------|------|
| 限流恢复 | `internal/proxy/scheduler/scheduler.go:startRateLimitRecoveryTask()` | 1分钟 | 自动恢复过期的限流账户 |
| 正常账号检查 | `internal/service/health_check.go:normalAccountLoop()` | 可配置(默认5分钟) | 定期检查正常OAuth账号有效性 |
| 问题账号探测 | `internal/service/health_check.go:problemAccountLoop()` | 1分钟 | 探测问题账号（限流/Token过期/疑似封号/封号） |

---

## 内存缓存结构

### 会话与并发控制（sync.Map）
| 数据类型 | 存储结构 | 说明 | 过期机制 |
|----------|----------|------|----------|
| 会话绑定 | `SessionStore (sync.Map)` | 会话→账户映射，含绑定时间/用户ID/TTL | 按 session_ttl 过期 |
| 账户并发 | `ConcurrencyManager (sync.Map)` | 账户当前并发数（atomic.Int64） | 按 concurrency_ttl 过期 |
| 用户并发 | `ConcurrencyManager (sync.Map)` | 用户当前并发数（atomic.Int64） | 按 concurrency_ttl 过期 |
| 不可用标记 | `UnavailableMarker (sync.Map)` | 账户临时不可用标记 | 按 unavailable_ttl 过期 |

### 缓存配置参数
| 参数 | 说明 | 默认值 |
|------|------|--------|
| `session_ttl` | 会话绑定过期时间（分钟） | 60 |
| `session_renewal_ttl` | 会话续期阈值（分钟） | 14 |
| `unavailable_ttl` | 不可用标记过期时间（分钟） | 5 |
| `concurrency_ttl` | 并发计数过期时间（分钟） | 5 |
| `default_concurrency_max` | 默认最大并发数 | 5 |

### 缓存代码位置
- 缓存服务: `internal/cache/memory.go`
- 缓存配置: `configs/config.yaml` 的 `cache` 节

---

## 数据流图

```
请求流程:
┌────────┐     ┌────────────┐     ┌────────────┐     ┌──────────┐
│ Client │────▶│ Middleware │────▶│  Handler   │────▶│ Service  │
└────────┘     └────────────┘     └────────────┘     └──────────┘
                    │                   │                  │
                    │                   │                  ▼
                    │                   │            ┌──────────┐
                    │                   │            │Repository│
                    │                   │            └──────────┘
                    ▼                   ▼                  │
              ┌──────────┐        ┌──────────┐            │
              │  Auth    │        │  Proxy   │            ▼
              │(JWT/Key) │        │ Adapter  │      ┌──────────┐
              └──────────┘        └──────────┘      │ Database │
                                       │            └──────────┘
                                       ▼
                                 ┌──────────┐
                                 │ Upstream │
                                 │   API    │
                                 └──────────┘
```

---

## 变更记录

### 2025-12-29: 首页动态效果与配置修复

**新增功能**：
1. 首页动态效果增强
   - Canvas 粒子系统（150粒子，120px连线距离）
   - 星空背景（100颗随机闪烁星星）
   - 数据流动画（5条垂直数据流）
   - 鼠标跟随光晕效果
   - 标题打字机效果
   - 数字滚动动画（CountUp组件）
   - 卡片鼠标跟踪径向渐变悬停效果
   - Hero区域元素交错淡入动画

2. 服务端点区域优化
   - 显示3个API平台配置用的Base URL
   - 每个端点带彩色徽章和独立复制按钮
   - Claude: `{{ baseUrl }}/claude`
   - OpenAI: `{{ baseUrl }}/openai`
   - Gemini: `{{ baseUrl }}/gemini`

**修复问题**：
1. Claude Code教程配置错误
   - 修复环境变量从 `{{ baseUrl }}` 改为 `{{ baseUrl }}/claude`
   - 修复快速复制配置和copyConfig函数

2. API接口文档端点显示优化
   - 移除多余的端点说明（流式、Codex CLI等）
   - 每个平台只显示核心端点

**修改文件**：
- `web/src/views/Home.vue` - 首页组件（动态效果、配置修复、端点显示）
- `docs/代码索引.md` - 添加Home.vue记录
- `docs/开发日志/2025-12-29.md` - 创建今日开发日志

---

### 2025-12-27: 账户 ModelMapping 过滤逻辑修复

**问题描述**：
当账户配置了 ModelMapping（如 `{"claude-opus-4-5-20251101":"MiniMax-M2.1"}`）且 AllowedModels 只允许目标模型时，账户被错误过滤掉无法使用。

**根本原因**：
`filterByAllowedModelsWithOriginal()` 函数在检查 AllowedModels 时，使用的是原始请求模型名（如 `claude-opus-4-5-20251101`），而不是账户 ModelMapping 映射后的目标模型名（如 `MiniMax-M2.1`）。

**修复方案**：
1. 新增 `getAccountMappedModel()` 函数，获取账户 ModelMapping 中原始模型对应的目标模型
2. 修改 `filterByAllowedModelsWithOriginal()` 函数：
   - 先检查账户的 ModelMapping 是否包含请求的模型
   - 如果包含，获取映射后的目标模型
   - 用映射后的目标模型去匹配 AllowedModels

**修改文件**：
- `internal/proxy/scheduler/scheduler.go`
  - 第344-413行: 重写 `filterByAllowedModelsWithOriginal()` 函数
  - 第478-501行: 新增 `getAccountMappedModel()` 函数

**关键代码**：
```go
// getAccountMappedModel 获取账户 ModelMapping 中原始模型对应的目标模型
func getAccountMappedModel(acc *model.Account, originalModel string) string {
    if acc.ModelMapping == "" {
        return ""
    }
    mapping := parseAccountModelMapping(acc)
    if mapping == nil {
        return ""
    }
    originalLower := strings.ToLower(originalModel)
    for sourceModel, targetModel := range mapping {
        sourceLower := strings.ToLower(sourceModel)
        if strings.HasPrefix(originalLower, sourceLower) || sourceLower == originalLower {
            return targetModel
        }
    }
    return ""
}
```

**相关代码位置**：
- 过滤函数: `internal/proxy/scheduler/scheduler.go:filterByAllowedModelsWithOriginal()`
- 映射获取: `internal/proxy/scheduler/scheduler.go:getAccountMappedModel()`

---

### 2025-12-27: Thinking Block Signature 错误自动处理

**问题描述**：
Claude 的 Extended Thinking 功能在 thinking block 中包含签名信息，该签名与特定的认证上下文（账户）绑定。当请求被路由到不同账户时，签名校验失败，返回 `Invalid signature in thinking block` 错误。

**根本原因**：
客户端发送的请求可能包含之前对话的 thinking block（带 signature），但代理可能将请求路由到不同的账户，导致签名验证失败。

**修复方案**：
1. 新增 `isSignatureError()` 函数检测 signature 错误
2. 新增 `removeThinkingBlocks()` 函数从请求体中移除 thinking blocks
3. 新增 `doSendWithRetry()` 和 `doSendStreamWithRetry()` 函数支持自动重试
4. 检测到 signature 错误时，自动移除 thinking blocks 并使用相同账户重新发送请求

**修改文件**：
- `internal/proxy/adapter/claude.go`
  - 第56-126行: 新增 `doSendWithRetry()` 非流式请求重试
  - 第140-425行: 新增 `doSendStreamWithRetry()` 流式请求重试
  - 第661-667行: 新增 `isSignatureError()` 检测函数
  - 第669-750行: 新增 `removeThinkingBlocks()` 移除函数

**关键代码**：
```go
// isSignatureError 检测是否是 thinking block signature 错误
func isSignatureError(errStr string) bool {
    return strings.Contains(errStr, "Invalid") &&
        strings.Contains(errStr, "signature") &&
        strings.Contains(errStr, "thinking")
}
```

**相关代码位置**：
- 错误检测: `internal/proxy/adapter/claude.go:isSignatureError()`
- 移除函数: `internal/proxy/adapter/claude.go:removeThinkingBlocks()`
- 非流式重试: `internal/proxy/adapter/claude.go:doSendWithRetry()`
- 流式重试: `internal/proxy/adapter/claude.go:doSendStreamWithRetry()`

---

### 2025-12-27: 移除全局模型映射

**需求描述**：
之前的全局模型映射会把 Claude 模型转换为其他模型（如 GLM-4.7），导致请求无法正确路由到 Claude 平台账户。

**修复方案**：
移除代理入口处的全局模型映射调用，只保留账户级别的 ModelMapping（在账户配置中设置）。

**修改文件**：
- `internal/handler/proxy.go`
  - `ClaudeMessages()` 第601行: 移除 `modelMappingService.MapModel()` 调用
  - `OpenAIChatCompletions()` 第647行: 移除全局模型映射
  - `GeminiChat()` 第711行: 移除全局模型映射

**影响范围**：
- Claude 接口：`POST /claude/v1/messages`
- OpenAI 接口：`POST /openai/v1/chat/completions`
- Gemini 接口：`POST /gemini/v1/chat`

**相关代码位置**：
- Claude 入口: `internal/handler/proxy.go:ClaudeMessages()`
- OpenAI 入口: `internal/handler/proxy.go:OpenAIChatCompletions()`
- Gemini 入口: `internal/handler/proxy.go:GeminiChat()`

---

### 2025-12-26: 账户AllowedModels过滤修复

**问题描述**：
账户设置了"允许的模型"（AllowedModels）后，其他模型仍然可以使用该账户。

**根本原因**：
账户的 `AllowedModels` 字段只保存到数据库，但调度器选择账户时**从未检查**这个字段。

**修复方案**：
在调度器中添加 `filterByAllowedModels()` 函数，在选择账户前进行过滤。

**修改文件**：
- `internal/proxy/scheduler/scheduler.go`
  - 第307-341行: 新增 `filterByAllowedModels()` 函数
  - 第150-154行: `SelectAccountWithSession()` 添加过滤
  - 第177,192-196行: `SelectAccountByType()` 添加过滤和参数
  - 第262,281-285行: `SelectAccountByTypeWithSession()` 添加过滤和参数
  - 第196,218-222行: `SelectAccountByTypesWithSession()` 添加过滤和参数
- `internal/handler/openai_responses.go`
  - 第178行: 更新调用，传递 modelName 参数

**功能说明**：
- 如果账户 `AllowedModels` 为空，该账户可用于所有模型
- 如果设置了 `AllowedModels`（逗号分隔），只有匹配的模型才能使用该账户
- 支持前缀匹配：如设置 `glm-4` 可以匹配 `glm-4-plus`、`glm-4.5` 等

**相关代码位置**：
- 过滤函数: `internal/proxy/scheduler/scheduler.go:filterByAllowedModels()`
- 调用位置: 所有 `SelectAccount*` 系列函数

---

### 2025-12-26: GLM缓存Token解析修复

**问题描述**：
智谱GLM通过Claude兼容API返回的缓存Token信息（cache_read_input_tokens）始终为0。

**根本原因**：
- Claude官方API: 缓存信息在 `message_start` 事件的 `message.usage` 中
- GLM兼容API: 缓存信息在 `message_delta` 事件的 `usage` 中

原代码只解析 `message_start` 事件，导致GLM的缓存信息丢失。

**修复方案**：
扩展 `parseStreamUsage()` 函数，同时解析 `message_delta` 事件中的缓存信息。

**修改文件**：
- `internal/proxy/adapter/claude.go` - parseStreamUsage() 函数
  - 第433-450行: 新增 message_delta 中 input_tokens 和 cache_read_input_tokens 解析

**关键代码**：
```go
case "message_delta":
    // Claude 标准格式只有 output_tokens
    if event.Usage.OutputTokens > 0 {
        result.OutputTokens = event.Usage.OutputTokens
    }
    // 兼容 GLM：如果 message_delta 中有 input_tokens，使用它
    if event.Usage.InputTokens > 0 && result.InputTokens == 0 {
        result.InputTokens = event.Usage.InputTokens
    }
    // 兼容 GLM：如果 message_delta 中有缓存信息，使用它
    if event.Usage.CacheReadInputTokens > 0 && result.CacheReadInputTokens == 0 {
        result.CacheReadInputTokens = event.Usage.CacheReadInputTokens
    }
```

**相关代码位置**：
- 缓存解析: `internal/proxy/adapter/claude.go:parseStreamUsage()` 第390-452行

---

### 2025-12-26: 流式响应末尾捕获（TailWriter）

**需求描述**：
请求日志中流式响应的response_body为空，无法查看末尾的usage/cache信息用于调试。

**实现方案**：
创建 TailWriter 结构体，在转发流式数据的同时捕获最后N字节内容。

**新增代码**：

`internal/proxy/adapter/adapter.go` - TailWriter:
```go
// TailWriter 包装 Writer，同时捕获末尾 N 字节
type TailWriter struct {
    w       io.Writer
    tail    []byte
    maxSize int
}

func NewTailWriter(w io.Writer, maxSize int) *TailWriter
func (t *TailWriter) Write(p []byte) (n int, err error)
func (t *TailWriter) Tail() []byte
func (t *TailWriter) Flush()
```

**修改文件**：
- `internal/proxy/adapter/adapter.go` - 新增 TailWriter 结构体（第160-205行）
- `internal/handler/proxy.go` - 所有流式Handler使用TailWriter
  - `handleOpenAIStreamWithRetry()` 第341行: 创建TailWriter(2KB)
  - `handleClaudeStreamWithRetry()` 第495行: 创建TailWriter(2KB)
  - `handleGeminiStream()` 第708行: 创建TailWriter(2KB)
  - `recordUsage()` 第1032-1034行: 流式响应添加 `[stream tail]` 前缀

**使用方式**：
```go
// 使用 TailWriter 捕获末尾 2KB 响应
tailWriter := adapter.NewTailWriter(writer, 2048)
// ... 流式处理使用 tailWriter ...
responseTail := tailWriter.Tail()
h.recordUsage(c, req.Model, result.Result, true, requestBody, responseTail, 200, result.AccountID)
```

**相关代码位置**：
- TailWriter定义: `internal/proxy/adapter/adapter.go:160-205`
- 使用示例: `internal/handler/proxy.go:handleClaudeStreamWithRetry()`

---

### 2025-12-25: 模型映射列表显示修复

**问题描述**：
模型管理页面添加模型映射成功后，映射列表不显示新添加的数据。

**根本原因**：
API 响应解析路径错误：
- 实际响应: `{code: 0, message: "success", data: {mappings: [...]}}`
- 错误代码: `res.mappings`
- 正确代码: `res.data?.mappings`

**修复方案**：
修正 `loadMappings()` 和 `loadMappingCacheStats()` 中的响应数据访问路径。

**修改文件**：
- `web/src/views/Models.vue` - 修复 API 响应解析
  - 第481-482行: `mappings.value = res.data?.mappings || []`
  - 第493行: `mappingCacheStats.value = res.data || null`

---

### 2025-12-25: 账户模型映射选择优化

**需求描述**：
账户管理中的模型映射应从全局配置的模型映射中选择，而不是手动输入。

**实现方案**：

| 原方案 | 新方案 |
|--------|--------|
| 手动输入源模型/目标模型 | 多选下拉框选择全局映射 |
| 逐条添加映射列表 | 一次选择多个已配置映射 |
| 编辑时显示原始映射 | 自动匹配到全局映射 ID |

**新增状态变量**：
```javascript
const globalMappings = ref([])
const loadingMappings = ref(false)
```

**新增方法**：
| 方法 | 说明 |
|------|------|
| `loadMappings()` | 加载启用的全局模型映射 |

**修改方法**：
| 方法 | 修改内容 |
|------|----------|
| `watch(visible)` | 加载映射列表，匹配已有映射到全局 ID |
| `buildSubmitData()` | 从选中 ID 构建 JSON 格式映射 |

**修改文件**：
- `web/src/components/AccountForm.vue` - 模型映射选择改造
  - 第787-789行: 新增 globalMappings 和 loadingMappings 变量
  - 第866-877行: 新增 loadMappings() 函数
  - 第1020-1044行: 修改 watch(visible) 加载和匹配逻辑
  - 第1204-1215行: 修改 buildSubmitData() 映射构建逻辑
  - 第630-656行: 新增模型映射多选下拉框模板
  - 第1688-1707行: 新增映射选项样式

**相关代码位置**：
- 全局映射加载: `web/src/components/AccountForm.vue:loadMappings()`
- 映射ID匹配: `web/src/components/AccountForm.vue` watch(visible) 回调
- 数据构建: `web/src/components/AccountForm.vue:buildSubmitData()`
- 下拉框模板: `web/src/components/AccountForm.vue` 模型映射 el-form-item

---

### 2025-12-24: 缓存管理页面显示改进

**需求描述**：
缓存管理页面的显示信息不够友好：
1. 并发限制显示错误（硬编码为 5/10，而非数据库值）
2. 账号/用户显示 ID 而非名称
3. 缺少 UserAgent 信息

**修复方案**：

1. **后端新增结构体** (`internal/service/cache.go`)：
   ```go
   type SimpleUserInfo struct {
       ID   uint   `json:"id"`
       Name string `json:"name"`
   }

   type SimpleAccountInfo struct {
       ID   uint   `json:"id"`
       Name string `json:"name"`
   }
   ```

2. **结构体字段变更**：
   - `AccountCacheInfo.Users`: `[]uint` → `[]SimpleUserInfo`
   - `UserCacheInfo.Accounts`: `[]uint` → `[]SimpleAccountInfo`

3. **方法改进**：
   - `ListAccountsWithCache()`: 批量查询用户信息，返回用户名和 max_concurrency
   - `ListUsersWithCache()`: 批量查询账号信息，返回账号名和 max_concurrency

4. **UserAgent 追踪**（贯穿整个请求流程）：
   - `SessionBinding` 结构体新增 `UserAgent` 字段
   - `RetryableRequest` 结构体新增 `UserAgent` 字段
   - `WithUserInfo()` 方法签名更新包含 userAgent 参数
   - 会话绑定创建时记录 UserAgent

**修改文件**：

后端：
- `internal/cache/memory.go` - MemorySessionBinding 添加 UserAgent 字段
- `internal/cache/session.go` - SessionBinding 添加 UserAgent 字段
- `internal/proxy/scheduler/retry.go` - RetryableRequest 添加 UserAgent
- `internal/handler/proxy.go` - getUserInfo 返回 UserAgent
- `internal/service/cache.go` - 新增结构体，改进查询方法
- `internal/repository/account.go` - 添加 GetByIDs() 批量查询

前端：
- `web/src/views/Cache.vue` - 显示名称而非 ID，显示正确的 max_concurrency

**API 响应变更**：

原响应：
```json
{
  "users": [1, 2, 3],
  "accounts": [10, 20],
  "max_concurrency": 5  // 硬编码
}
```

新响应：
```json
{
  "users": [{"id": 1, "name": "张三"}, {"id": 2, "name": "李四"}],
  "accounts": [{"id": 10, "name": "Claude-Pro"}, {"id": 20, "name": "GPT-4"}],
  "max_concurrency": 50  // 来自数据库
}
```

**相关代码位置**：
- 新结构体: `internal/service/cache.go:256-266`
- 账号列表改进: `internal/service/cache.go:290-384`
- 用户列表改进: `internal/service/cache.go:386-483`
- 前端显示: `web/src/views/Cache.vue:82-89, 164-171`

---

### 2025-12-24: 移除 Redis 依赖，改用内存缓存

**需求描述**：
简化部署架构，移除 Redis 依赖，使用 Go 原生 sync.Map + atomic.Int64 实现内存缓存。

**架构变更**：
| 功能 | 原实现 (Redis) | 新实现 (sync.Map) |
|------|---------------|-------------------|
| 会话绑定 | Redis Hash + TTL | `sync.Map` + 定期清理 goroutine |
| 并发计数 | Redis INCR/DECR | `atomic.Int64` + CAS 操作 |
| 不可用标记 | Redis String + EXPIRE | `sync.Map` + TTL 字段 |

**新增方法**：
| 方法 | 文件 | 说明 |
|------|------|------|
| `ConcurrencyManager.Stats()` | `internal/cache/memory.go` | 返回账户/用户并发计数器数量 |

**修改方法**：
| 方法 | 文件 | 修改内容 |
|------|------|----------|
| `MemoryCache.Stats()` | `internal/cache/memory.go` | 新增 account_concurrency_count/user_concurrency_count |
| `MemoryCacheStats` struct | `internal/service/system_monitor.go` | 添加 AccountConcurrencyCount/UserConcurrencyCount 字段 |
| `GetCacheStats()` | `internal/service/system_monitor.go` | 从 MemoryCache.Stats() 读取新增字段 |

**API 变更**：
| 接口 | 变更内容 |
|------|----------|
| `GET /api/admin/monitor` | 响应字段从 `redis` 改为 `cache` |
| `GET /api/admin/monitor/redis` | 改为 `GET /api/admin/monitor/cache` |

**删除文件**：
- `internal/cache/redis.go` - Redis 客户端封装
- `internal/service/redis_sync.go` - Redis 数据同步服务

**相关代码位置**：
- 内存缓存核心: `internal/cache/memory.go`
- 监控服务: `internal/service/system_monitor.go:60-185`
- 缓存 API: `internal/handler/cache.go`
- 前端监控: `web/src/views/SystemMonitor.vue`

---

### 2025-12-24: 操作日志功能修复

**问题描述**：
操作日志系统存在多个 BUG 导致审计信息记录不完整：
1. 登录操作的 `user_id` 和 `username` 始终为空
2. 更新/删除操作的 `target_name` 始终为空

**根本原因**：
1. 登录请求在认证中间件之前处理，context 中没有用户信息
2. `c.Param("id")` 在通用中间件中无法获取路由参数（Gin 路由尚未解析）
3. 被操作用户可能已软删除，GORM 默认排除软删除记录

**修复方案**：

| 问题 | 解决方案 |
|------|----------|
| 登录日志用户信息 | 从登录成功响应 JSON 中提取 user_id/username |
| 路径ID提取 | 使用正则表达式从 URL 路径提取 ID |
| 软删除记录 | 所有查询函数改用 `Unscoped()` 包含软删除记录 |

**新增正则表达式**：
```go
var (
    pathIDPattern       = regexp.MustCompile(`/(\d+)(?:/|$)`)
    secondPathIDPattern = regexp.MustCompile(`/(\d+)/[^/]+/(\d+)(?:/|$)`)
)
```

**修改文件**：
- `internal/middleware/operation_log.go` - 操作日志中间件
  - 第149-186行: 新增路径ID提取正则和函数 `getPathID()`, `getSecondPathID()`
  - 第251-357行: 所有 `getXxxNameByID()` 函数改用 `Unscoped()` 查询
  - 第720-732行: 登录响应解析提取用户信息

**修复函数列表**：
| 函数 | 修改内容 |
|------|----------|
| `getPathID()` | 添加正则提取 URL 路径中第一个数字ID |
| `getSecondPathID()` | 添加正则提取嵌套路径中第二个数字ID |
| `getUsernameByID()` | 改用 `repository.DB.Unscoped().First()` |
| `getAccountNameByID()` | 改用 `repository.DB.Unscoped().First()` |
| `getGroupNameByID()` | 改用 `repository.DB.Unscoped().First()` |
| `getAPIKeyNameByID()` | 改用 `repository.DB.Unscoped().First()` |
| `getModelNameByID()` | 改用 `repository.DB.Unscoped().First()` |
| `getProxyNameByID()` | 改用 `repository.DB.Unscoped().First()` |
| `getPackageNameByID()` | 改用 `repository.DB.Unscoped().First()` |
| `getUserPackageNameByID()` | 改用 `repository.DB.Unscoped().Preload("Package").First()` |

**相关代码位置**：
- 路径ID提取: `internal/middleware/operation_log.go:149-186`
- 软删除查询: `internal/middleware/operation_log.go:251-357`
- 登录响应解析: `internal/middleware/operation_log.go:720-732`
- 目标名称获取: `internal/middleware/operation_log.go:754-761`

---

### 2025-12-23: HTTP 客户端连接池优化

**需求描述**：
优化 HTTP 客户端性能，使用全局预配置客户端和代理客户端缓存，减少每次请求创建新客户端的开销。

**新增全局客户端**：
| 客户端 | 超时 | 用途 |
|--------|------|------|
| `defaultHTTPClient` | 120s | 普通请求 |
| `defaultStreamClient` | 600s | 流式请求 |

**连接池参数**：
| 参数 | 值 | 说明 |
|------|-----|------|
| `MaxIdleConns` | 100 | 全局最大空闲连接数 |
| `MaxIdleConnsPerHost` | 20 | 每个主机最大空闲连接 |
| `IdleConnTimeout` | 90s | 空闲连接超时时间 |

**新增缓存机制**：
- `proxyClientCache`: 代理客户端缓存（避免重复创建）
- `proxyClientCacheLock`: sync.RWMutex 保证并发安全

**新增函数**：
| 函数 | 文件 | 说明 |
|------|------|------|
| `getOrCreateProxyClient()` | `http_client.go:88` | 获取或创建代理客户端（带缓存） |
| `ClearProxyClientCache()` | `http_client.go:567` | 清理指定代理的客户端缓存 |
| `ClearAllProxyClientCache()` | `http_client.go:581` | 清理所有代理客户端缓存 |
| `GetProxyClientCacheStats()` | `http_client.go:593` | 获取代理客户端缓存统计 |

**修改文件**：
- `internal/proxy/adapter/http_client.go` - HTTP 客户端管理
  - 第28-64行: 新增全局客户端和缓存变量
  - 第66-86行: 修改 `GetHTTPClient()` 和 `GetStreamHTTPClient()` 使用缓存
  - 第88-218行: 新增 `getOrCreateProxyClient()` 缓存逻辑
  - 第567-635行: 新增缓存管理函数

---

### 2025-12-22: 账号健康检测系统优化 - 分级检测策略

**需求描述**：
优化账号健康检测系统，实现分级检测策略：
1. 每次 API 请求即为隐式检测，发现问题立即更新状态
2. 问题账号进入专门的检测池，按状态分级探测
3. 限流账号主动探测（不盲目等待官方 reset 时间）
4. 疑似封号需要多次确认才标记为真正封号
5. 所有检测策略可通过 Web 界面配置

**新增账号状态类型**：
| 状态 | 说明 |
|------|------|
| `valid` | 正常 |
| `invalid` | 无效（兼容旧状态） |
| `rate_limited` | 限流中 |
| `overloaded` | 过载 |
| `token_expired` | Token 过期（新增） |
| `suspended` | 疑似封号（新增） |
| `banned` | 已封号（新增） |
| `disabled` | 已禁用（新增） |

**新增数据库字段**（Account 模型）：
| 字段 | 类型 | 说明 |
|------|------|------|
| `suspended_count` | int | 疑似封号连续失败计数 |
| `last_health_check_at` | *time.Time | 上次健康检测时间 |
| `next_health_check_at` | *time.Time | 下次健康检测时间 |
| `health_check_interval` | int | 当前检测间隔（分钟） |

**新增配置项**：
| 配置项 | 说明 | 默认值 |
|--------|------|--------|
| `health_check_auto_recovery` | 检测通过时自动恢复 | true |
| `health_check_auto_token_refresh` | Token 过期时自动刷新 | true |
| `rate_limited_probe_enabled` | 启用限流账号主动探测 | true |
| `rate_limited_probe_init_interval` | 限流探测初始间隔（分钟） | 10 |
| `rate_limited_probe_max_interval` | 限流探测最大间隔（分钟） | 30 |
| `rate_limited_probe_backoff` | 限流探测退避因子 | 1.5 |
| `suspended_probe_interval` | 疑似封号探测间隔（分钟） | 5 |
| `suspended_confirm_threshold` | 确认封号阈值（次数） | 3 |
| `banned_probe_enabled` | 启用封号账号复活检测 | false |
| `banned_probe_interval` | 封号复活探测间隔（小时） | 1 |
| `token_refresh_cooldown` | Token 刷新冷却时间（分钟） | 30 |
| `token_refresh_max_retries` | Token 刷新最大重试次数 | 3 |

**分级检测策略**：

```
┌─────────────────────────────────────────────────────────────────┐
│                      健康检测服务                                │
├─────────────────────────────────────────────────────────────────┤
│  normalAccountLoop (慢)          problemAccountLoop (快/每分钟)  │
│  ├─ 检查正常账号                  ├─ rate_limited: 主动探测      │
│  └─ 间隔：配置的检测间隔           │   └─ 指数退避，不等 reset_at  │
│                                   ├─ token_expired: 自动刷新     │
│                                   ├─ suspended: 确认检测         │
│                                   │   └─ N次失败 → banned        │
│                                   └─ banned: 复活检测（可选）     │
└─────────────────────────────────────────────────────────────────┘
```

**新增 API 接口**：
| 接口 | 方法 | 说明 |
|------|------|------|
| `/api/admin/accounts/:id/health-check` | POST | 手动触发单个账号检测 |
| `/api/admin/accounts/:id/recover` | POST | 强制恢复账号 |
| `/api/admin/accounts/:id/refresh-token` | POST | 刷新账号 Token |
| `/api/admin/health-check/status` | GET | 获取健康检测服务状态 |
| `/api/admin/health-check/trigger` | POST | 触发全局健康检测 |

**修改文件**：

后端：
- `internal/model/account.go` - 新增状态常量和数据库字段
- `internal/model/system_config.go` - 新增配置常量
- `internal/service/config.go` - 新增配置获取方法
- `internal/repository/account.go` - 新增健康检测相关数据库操作
  - `GetProblemAccounts()` - 获取问题账号列表
  - `GetAccountsNeedingProbe()` - 获取需要探测的账号
  - `UpdateHealthCheckSchedule()` - 更新检测计划
  - `IncrementSuspendedCount()` - 增加疑似封号计数
  - `MarkAsSuspended()` / `MarkAsBanned()` / `MarkAsTokenExpired()` - 状态标记
  - `RecoverAccount()` / `ForceRecoverAccount()` - 账号恢复
- `internal/service/health_check.go` - 重构健康检测服务
  - `normalAccountLoop()` - 正常账号检测循环
  - `problemAccountLoop()` - 问题账号探测循环（每分钟）
  - `handleRateLimitedAccount()` - 限流账号处理（指数退避）
  - `handleTokenExpiredAccount()` - Token 过期处理
  - `handleSuspendedAccount()` - 疑似封号处理（确认机制）
  - `handleBannedAccount()` - 封号账号复活检测
  - `TriggerSingleCheck()` - 单个账号检测
  - `ForceRecover()` - 强制恢复
  - `RefreshToken()` - Token 刷新
- `internal/handler/account.go` - 新增 API Handler
- `internal/handler/routes.go` - 新增路由

前端：
- `web/src/api/index.js` - 新增健康检测 API
- `web/src/views/Settings.vue` - 分级检测策略配置界面
  - 健康检查基础配置
  - 恢复策略配置
  - 限流账号探测配置
  - 疑似封号检测配置
  - 封号账号复活检测配置
  - Token 刷新配置
  - 健康检测状态弹窗
- `web/src/views/Accounts.vue` - 账号列表优化
  - 新增状态筛选选项（Token过期/疑似封号/已封号/已禁用）
  - 状态展示增强（限流倒计时/下次检测时间/连续失败次数/错误信息）
  - 新增操作按钮（检测/恢复/刷新Token）
  - 新增状态样式

**相关代码位置**：
- 状态常量: `internal/model/account.go:21-34`
- 配置常量: `internal/model/system_config.go:40-60`
- 问题账号循环: `internal/service/health_check.go:problemAccountLoop()`
- 限流处理: `internal/service/health_check.go:handleRateLimitedAccount()`
- 封号确认: `internal/service/health_check.go:handleSuspendedAccount()`
- 前端配置: `web/src/views/Settings.vue` 健康检查卡片
- 前端账号列表: `web/src/views/Accounts.vue` 状态列和操作列

---

### 2025-12-22: Claude 流式传输 - SSE 首个事件错误检测与重试

**问题描述**：
Claude 流式请求断流，上游代理返回 `permission_error: Permission denied` SSE 错误事件。

**根本原因分析**：
1. 上游代理 (`154.219.106.53:3000`) 频繁返回 SSE 错误事件
2. 错误直接透传给客户端，导致流异常结束（"断流"）
3. 需要在写入客户端前检测错误，以触发重试机制

**修复方案**：
实现首个事件错误检测，在向客户端写入前拦截 SSE 错误：
1. 使用 `resp.Body.Read()` 直接读取数据块（32KB 缓冲区）
2. 缓冲首个事件的行（`event:` 和 `data:`），直到看到 `data:` 行
3. 解析 `data:` 行，检测是否为错误事件（`type: "error"`）
4. 如果是错误事件，**不写入客户端**，返回错误以触发重试
5. 如果不是错误，写入缓冲的行后正常转发

**修改文件**：

`internal/proxy/adapter/claude.go` - 流式处理（第217-366行）:
```go
// 首个事件检测：用于在写入客户端前检测 SSE 错误
var firstEventChecked bool
var pendingLines []string // 缓冲首个事件的行

for {
    n, readErr := resp.Body.Read(readBuf)
    if n > 0 {
        // 按换行符分割处理
        for i := 0; i < len(lines)-1; i++ {
            line := lines[i]

            // === 首个事件检测逻辑 ===
            if !firstEventChecked {
                pendingLines = append(pendingLines, line)

                if strings.HasPrefix(line, "data: ") {
                    // 解析检查是否是错误事件
                    if errEvent.Type == "error" && errEvent.Error != nil {
                        // 首个事件是错误，返回错误以触发重试（不写入客户端）
                        return result, NewUpstreamError(500, fmt.Sprintf("%s: %s",
                            errEvent.Error.Type, errEvent.Error.Message))
                    }
                    // 首个事件正常，写入缓冲的行
                    firstEventChecked = true
                    for _, pendingLine := range pendingLines {
                        writer.Write([]byte(pendingLine + "\n"))
                    }
                }
                continue
            }

            // === 正常转发逻辑 ===
            writer.Write([]byte(line + "\n"))
        }
    }
}
```

**重试机制**：
`internal/proxy/scheduler/retry.go` 中 `isConnectionError()` 方法已包含 SSE 错误类型：
```go
sseRetryableErrors := []string{
    "permission_error",
    "authentication_error",
    "overloaded_error",
    "rate_limit_error",
    "api_error",
}
```

**关键改进**：
- ✅ 首个事件错误检测，避免错误透传给客户端
- ✅ 错误触发重试机制，尝试切换账户
- ✅ 使用 buffer 正确处理不完整行
- ✅ Usage 解析不阻塞数据传输

**注意事项**：
- 如果只有单个账户，重试会选择同一账户，效果有限
- 建议配置多个账户以启用故障切换

---

### 2025-12-21: SSE 错误事件检测与重试机制

**问题描述**：
Claude 流式请求出现断流，日志显示 `总行数: 3 | InputTokens: 0 | OutputTokens: 0`。

**根本原因**：
上游返回 HTTP 200 但发送 SSE 错误事件：
```
event: error
data: {"type":"error","error":{"type":"permission_error","message":"Permission denied"}}
```
原代码没有检测 SSE 错误事件，直接透传给客户端导致流异常结束。

**修复方案**：
1. 缓冲首个 `event:` 行，等到看到 `data:` 行再决定是否发送
2. 如果首个事件是 `error` 类型，不写入客户端，直接返回错误触发重试
3. 在重试逻辑中添加 SSE 错误类型作为可重试错误

**修改文件**：

`internal/proxy/adapter/claude.go` - SSE 错误检测:
- 第220-224行: 新增变量
  ```go
  var debugLines []string   // 记录前几行用于调试
  var lastEventType string  // 记录上一个 event 类型
  var firstEventChecked bool // 是否已检查首个事件
  var pendingEventLine []byte // 缓冲的 event 行
  ```
- 第250-258行: 检测 event 类型并缓冲
  ```go
  if strings.HasPrefix(lineStr, "event: ") {
      lastEventType = strings.TrimPrefix(lineStr, "event: ")
      if !firstEventChecked {
          pendingEventLine = make([]byte, len(line))
          copy(pendingEventLine, line)
          continue // 不立即写入，等待 data 行
      }
  }
  ```
- 第261-292行: 检测首个事件是否为错误
  ```go
  if !firstEventChecked && lastEventType == "error" {
      // 解析错误事件
      // 不写入客户端，直接返回错误以触发重试
      return result, NewUpstreamError(500, fmt.Sprintf("%s: %s", errEvent.Error.Type, errEvent.Error.Message))
  }
  // 首个事件检查完毕，写入缓冲的 event 行
  if !firstEventChecked && len(pendingEventLine) > 0 {
      writer.Write(pendingEventLine)
      writer.Write([]byte("\n"))
  }
  firstEventChecked = true
  ```
- 第317-320行: 调试日志
  ```go
  if lineCount <= 10 {
      log.Warn("Claude Stream 行数异常少 | 总行数: %d | 内容: %v", lineCount, debugLines)
  }
  ```

`internal/proxy/scheduler/retry.go` - 重试逻辑:
- 第455-496行: `isConnectionError()` 方法
  ```go
  // SSE 首个事件为错误（尚未向客户端写入数据，可安全重试）
  sseRetryableErrors := []string{
      "permission_error",
      "authentication_error",
      "overloaded_error",
      "rate_limit_error",
      "api_error",
  }
  ```

**调试日志**：
- `Claude Stream 行数异常少 | 总行数: %d | 内容: %v` - 记录短流的内容
- `Claude Stream 首个事件为错误 | Type: %s | Message: %s` - 检测到 SSE 错误

**待解决问题**：
断流问题仍可能存在，需要进一步排查：
1. 上游服务返回 `permission_error` 的原因需要分析
2. 只有单个账户时无法切换重试
3. 可能需要添加更多 SSE 错误类型到可重试列表

---

### 2025-12-21: ClaudeConsole (API Key) 账户移除限流处理

**问题描述**：
用户要求对 API Key 模式（ClaudeConsole 类型）的账户不进行限流处理，因为 API Key 模式由上游直接控制限流。

**修复方案**：
1. 不提取 ClaudeConsole 账户的限流响应头
2. 不对 ClaudeConsole 账户执行限流状态标记

**修改文件**：

`internal/proxy/adapter/claude.go` - 响应头提取:
- 第98-101行 (`Send` 方法):
  ```go
  // 仅对 OAuth/SessionKey 模式提取限流头，API Key 模式不需要
  if account.Type != model.AccountTypeClaudeConsole {
      response.Headers = extractRateLimitHeaders(resp.Header)
  }
  ```
- 第154-157行 (`SendStream` 方法):
  ```go
  // 仅对 OAuth/SessionKey 模式提取限流头，API Key 模式不需要
  if account.Type != model.AccountTypeClaudeConsole {
      result.Headers = extractRateLimitHeaders(resp.Header)
  }
  ```

`internal/proxy/scheduler/scheduler.go` - 限流标记:
- 第351-356行 (`MarkAccountErrorWithReset` 方法):
  ```go
  // API Key 模式（ClaudeConsole）不做限流处理，直接透传上游错误
  if accountType == model.AccountTypeClaudeConsole {
      // API Key 模式只记录错误，不改变状态
      s.repo.IncrementErrorCount(accountID)
      return
  }
  ```

---

### 2025-12-19: 账号健康检查服务

**需求描述**：
定期检查 OAuth/SessionKey 类型账号的有效性，自动禁用连续错误达到阈值的账号。

**适用场景**：
- `claude-official` 账号 OAuth Token / SessionKey 过期
- `openai-responses` 账号 ChatGPT OAuth Token / API Key 失效
- `gemini` 账号 OAuth Token 失效

**不适用场景**：
- 纯 API Key 类型账号（如 `openai`、`gemini-api`）

**实现方案**：
1. 新增 `AccountHealthCheckService` 单例服务
2. 定时检查 OAuth/SessionKey 账号有效性
3. 使用轻量级 API 调用验证（不消耗 Token）
4. 连续错误达到阈值自动禁用账号

**新增文件**：
- `internal/service/health_check.go` - 健康检查服务
  - `AccountHealthCheckService` - 服务结构体
  - `Start()` / `Stop()` / `Restart()` - 服务生命周期管理
  - `checkLoop()` - 检查循环
  - `doCheck()` - 执行检查（并发控制，最多5个并发）
  - `checkAccount()` - 根据账号类型分发检查
  - `checkClaudeOfficial()` - Claude 账号检查（支持 OAuth 和 SessionKey 双重验证）
  - `checkClaudeOAuth()` - Claude OAuth 验证（GET /api/oauth/usage）
  - `checkClaudeSessionKey()` - Claude SessionKey 验证（GET /api/organizations）
  - `checkOpenAIResponses()` - OpenAI Responses 账号检查
  - `checkChatGPTOAuth()` - ChatGPT OAuth Token 验证（GET /backend-api/accounts/check）
  - `checkGemini()` - Gemini 账号检查（GET /v1beta/models）
  - `GetStatus()` - 获取服务状态
  - `OnConfigChange()` - 配置变更回调

**修改文件**：
- `internal/model/account.go` - 添加 `ConsecutiveErrorCount` 字段
- `internal/model/system_config.go` - 添加健康检查配置常量
- `internal/service/config.go` - 添加健康检查配置便捷方法
- `internal/repository/account.go` - 添加健康检查相关数据库操作
  - `GetAccountsForHealthCheck()` - 获取需要检查的账号
  - `IncrementConsecutiveErrorCount()` - 增加连续错误计数
  - `ResetConsecutiveErrorCount()` - 重置连续错误计数
  - `DisableAccountByHealthCheck()` - 因健康检查失败禁用账号
- `cmd/server/main.go` - 添加健康检查服务启动和关闭逻辑
- `web/src/views/Settings.vue` - 前端添加健康检查配置界面

**配置项**：
| 配置项 | 说明 | 默认值 |
|--------|------|--------|
| `account_health_check_enabled` | 是否启用 | false |
| `account_health_check_interval` | 检查间隔（分钟） | 5 |
| `account_error_threshold` | 连续错误阈值 | 5 |

**验证方式**：

| 账号类型 | 认证方式 | 验证端点 | 说明 |
|----------|----------|----------|------|
| claude-official | OAuth (AccessToken) | `https://api.anthropic.com/api/oauth/usage` | 优先验证 |
| claude-official | SessionKey | `https://claude.ai/api/organizations` | OAuth失败时回退 |
| openai-responses | API Key | `https://api.openai.com/v1/models` | 标准验证 |
| openai-responses | ChatGPT OAuth | `https://chatgpt.com/backend-api/accounts/check/v4-2023-04-27` | JWT Token 验证 |
| gemini | OAuth | `https://generativelanguage.googleapis.com/v1beta/models` | 模型列表验证 |

**检查逻辑**：
- HTTP 200: 健康，重置连续错误计数
- HTTP 401/403: 认证失败，连续错误+1
- HTTP 429: 限流，视为健康（账号有效只是限流）
- 达到阈值: 禁用账号，刷新调度器缓存

**相关代码位置**：
- 服务定义: `internal/service/health_check.go:AccountHealthCheckService`
- 检查循环: `internal/service/health_check.go:checkLoop()` 第87-121行
- 执行检查: `internal/service/health_check.go:doCheck()` 第129-228行
- Claude OAuth 验证: `internal/service/health_check.go:checkClaudeOAuth()` 第279-339行
- Claude SessionKey 验证: `internal/service/health_check.go:checkClaudeSessionKey()` 第341-384行
- ChatGPT OAuth 验证: `internal/service/health_check.go:checkChatGPTOAuth()` 第455-536行
- 启动逻辑: `cmd/server/main.go` 第147-165行

---

### 2025-12-19: OpenAI Responses 接口多账户类型支持

**问题描述**：
`/responses` 接口只选择 `openai-responses` 类型账户，导致使用第三方 OpenAI API（类型为 `openai`）的用户无法调用，返回 503 Service Unavailable。

**根本原因**：
第三方 OpenAI API 提供商也支持 `/responses` 端点（如 Codex 接口），但其账户类型配置为 `openai`，原有代码只从 `openai-responses` 类型中选择账户。

**修复方案**：
1. 调度器新增 `SelectAccountByTypesWithSession()` 方法，支持从多个账户类型中选择
2. `/responses` 接口同时支持 `openai-responses` 和 `openai` 两种账户类型

**新增代码**：
- `internal/proxy/scheduler/scheduler.go` - 新增 `SelectAccountByTypesWithSession()` 方法
  - 从多个账户类型获取账户列表
  - 支持会话粘性（内存缓存绑定）
  - 基于权重的账户选择

**修改文件**：
- `internal/handler/openai_responses.go` - 账户选择改用多类型方法
  - 从 `SelectAccountByTypeWithSession()` 改为 `SelectAccountByTypesWithSession()`
  - 账户类型数组：`[]string{model.AccountTypeOpenAIResponses, model.AccountTypeOpenAI}`

**相关代码位置**：
- 多类型选择: `internal/proxy/scheduler/scheduler.go:SelectAccountByTypesWithSession()` 第186-243行
- Handler 调用: `internal/handler/openai_responses.go:HandleResponses()` 第140-142行

**相关功能 - 会话粘性**：
本次修复同时完善了 OpenAI Responses 的会话粘性功能：
- 会话哈希生成：优先使用 `Session_id` 请求头，其次使用 `instructions` 字段，最后使用第一条消息内容
- 会话绑定：将会话与账户绑定到内存缓存，后续相同会话的请求路由到同一账户
- 代码位置：`internal/handler/openai_responses.go:generateSessionHash()` 第522-583行

---

### 2025-12-18: Chrome TLS 指纹支持与 OpenAI OAuth 修复

**需求描述**：
1. OpenAI 等平台可能检测 TLS 指纹，需要模拟 Chrome 浏览器的 TLS 特征
2. OpenAI OAuth 链接使用错误的 CLIENT_ID
3. OpenAI Responses 需要支持 Session Key（OAuth access token）认证

**实现方案**：
1. 在 `http_client.go` 中添加 Chrome TLS 指纹支持（使用 uTLS 库模拟 Chrome 120）
2. 修复 OpenAI OAuth 配置，使用正确的 CLIENT_ID: `app_EMoamEEZ73f0CkXaXp7hrann`
3. OpenAI Responses 适配器支持 SessionKey 和 APIKey 两种认证方式

**新增/修改文件**：
- `internal/proxy/adapter/http_client.go` - 新增 Chrome TLS 相关函数
  - `GetChromeTLSClient()` - 获取带 Chrome TLS 指纹的 HTTP 客户端
  - `GetSmartHTTPClient()` - 智能选择 HTTP 客户端（自动判断是否需要 Chrome TLS）
  - `dialTLSWithChrome()` - 使用 Chrome TLS 指纹建立 TLS 连接
  - `dialWithProxy()` - 通过代理建立连接（支持 SOCKS5/HTTP）
  - `NeedsChromeTLS()` - 判断目标是否需要 Chrome TLS
- `internal/proxy/adapter/openai_responses.go` - 使用 Chrome TLS 和 SessionKey 认证
- `internal/handler/oauth.go` - 修复 OpenAI OAuth 配置
  - 新增 `OpenAIClientID`, `OpenAITokenURL`, `OpenAIAuthorizeURL` 常量
  - 新增 `exchangeOpenAIToken()` 函数

**需要 Chrome TLS 的域名**：
- `chatgpt.com`
- `claude.ai`
- `api.openai.com`
- `auth.openai.com`

**认证逻辑**：
```go
// 优先使用 SessionKey（OAuth access token），否则使用 APIKey
authToken := account.APIKey
if account.SessionKey != "" {
    authToken = account.SessionKey
}
```

**相关代码位置**：
- Chrome TLS 客户端: `internal/proxy/adapter/http_client.go:GetChromeTLSClient()` 第141-155行
- 智能客户端选择: `internal/proxy/adapter/http_client.go:GetSmartHTTPClient()` 第327-334行
- OpenAI OAuth 常量: `internal/handler/oauth.go` 第37-41行
- OpenAI Token 交换: `internal/handler/oauth.go:exchangeOpenAIToken()` 第560-614行

---

### 2025-12-17: OpenAI Responses API 会话粘性支持

**需求描述**：
OpenAI Responses API 需要支持会话粘性功能，确保同一 API Key 的请求始终路由到同一后端账户，避免多账户间切换导致的会话状态不一致问题。

**问题原因**：
原有的 `SelectAccountByType()` 方法仅做随机权重选择，不支持会话缓存绑定。

**修复方案**：
1. 在调度器中新增 `SelectAccountByTypeWithSession()` 方法，支持按账户类型选择并绑定会话
2. 修改 OpenAI Responses Handler 使用新方法

**新增代码**：
- `internal/proxy/scheduler/scheduler.go` - 新增 `SelectAccountByTypeWithSession()` 方法
  - 检查内存缓存会话绑定
  - 验证绑定账户是否可用
  - 账户不可用时自动移除绑定重新选择
  - 新选择账户后创建会话绑定

**修改文件**：
- `internal/handler/openai_responses.go` - 修改账户选择逻辑
  - 从 `SelectAccountByType()` 改为 `SelectAccountByTypeWithSession()`
  - Session ID 格式：`apikey:{apiKeyID}`

**关键代码**：
```go
// openai_responses.go 中的账户选择
sessionID := fmt.Sprintf("apikey:%d", apiKeyID)
account, err := h.scheduler.SelectAccountByTypeWithSession(ctx, model.AccountTypeOpenAIResponses, sessionID, userID, apiKeyID)
```

**测试验证**：
- 4个不同 API Key 并发请求，分别绑定到4个不同账户
- 第二轮请求全部命中缓存账户
- TTL 验证正常（~3600秒）

**相关代码位置**：
- 会话粘性调度: `internal/proxy/scheduler/scheduler.go:SelectAccountByTypeWithSession()` 第186-244行
- Handler 调用: `internal/handler/openai_responses.go:HandleResponses()` 账户选择部分

---

### 2025-12-16: OpenAI Responses API 转发功能

**需求描述**：
实现 OpenAI Responses API（Codex）的转发功能，支持 Claude Code、Codex CLI 等客户端的 `/responses` 接口请求。

**实现方案**：
参考 claude-relay 项目的 `openaiResponsesRelayService.js` 实现：
1. 直接字节流转发（不解析 SSE 格式），保持流完整性
2. 同时解析 SSE 事件获取 usage 数据用于统计
3. 支持流式和非流式响应
4. 按账户类型 `openai-responses` 调度账户

**新增文件**：
- `internal/handler/openai_responses.go` - OpenAI Responses Handler
  - `HandleResponses()` - 主处理函数，处理 `/responses` 请求
  - `handleStreamResponse()` - 流式响应处理（直接字节转发）
  - `handleNormalResponse()` - 非流式响应处理
  - `parseSSEForUsage()` - 从 SSE 流中解析 usage 信息
  - `setRequestHeaders()` - 设置转发请求头
- `internal/proxy/adapter/openai_responses.go` - OpenAI Responses 适配器

**修改文件**：
- `internal/handler/routes.go` - 添加 `/responses` 和 `/v1/responses` 路由
- `internal/model/account.go` - 添加 `AccountTypeOpenAIResponses` 常量
- `README.md` - 添加 OpenAI Responses API 使用说明

**路由配置**：
| 路径 | 方法 | 说明 | 中间件 |
|------|------|------|--------|
| `/responses` | POST | OpenAI Responses API | APIKeyAuth, ClientFilter, UserConcurrency |
| `/v1/responses` | POST | OpenAI Responses API | APIKeyAuth, ClientFilter, UserConcurrency |

**关键技术点**：
1. **直接字节转发**：使用 `Read` + `Write` 直接转发原始字节，不破坏 SSE 格式
   ```go
   buf := make([]byte, 32*1024)
   for {
       n, err := resp.Body.Read(buf)
       if n > 0 {
           c.Writer.Write(buf[:n])
           c.Writer.Flush()
       }
   }
   ```

2. **Usage 解析**：在转发的同时解析 `response.completed` 事件获取 token 统计
   ```go
   // 解析 type: response.completed 事件
   if eventType == "response.completed" {
       // 提取 usage.input_tokens 和 usage.output_tokens
   }
   ```

3. **URL 构建**：`targetURL = baseURL + requestPath`（与 claude-relay 一致）

**相关代码位置**：
- Handler 入口: `internal/handler/openai_responses.go:HandleResponses()` 第36-131行
- 流式处理: `internal/handler/openai_responses.go:handleStreamResponse()` 第185-240行
- SSE 解析: `internal/handler/openai_responses.go:parseSSEForUsage()` 第244-296行

---

### 2025-12-16: 系统日志支持服务器日志

**需求描述**：
在系统日志模块中增加查看服务器系统日志的功能（如 `/var/log/auth.log`、`/var/log/syslog` 等），方便在管理后台直接查看 SSH 登录尝试、系统事件等。

**实现方案**：
- 后端增加服务器日志支持，使用白名单机制限制可访问的日志文件（安全考虑）
- 前端增加 Tab 切换，区分"应用日志"和"服务器日志"
- 所有 API 增加 `source` 参数（`app` 或 `server`）
- 服务器日志禁止删除操作

**白名单日志文件**：
| 文件 | 说明 |
|------|------|
| `auth.log` / `auth.log.1` | SSH认证日志 |
| `syslog` / `syslog.1` | 系统日志 |
| `kern.log` / `kern.log.1` | 内核日志 |
| `dpkg.log` | 软件包日志 |
| `fail2ban.log` | Fail2ban日志 |
| `nginx/access.log` | Nginx访问日志 |
| `nginx/error.log` | Nginx错误日志 |
| `mysql/error.log` | MySQL错误日志 |

**修改文件**：
- `internal/handler/system_log.go` - 增加服务器日志支持
  - 新增 `serverLogDir` 和 `allowedServerLogs` 白名单
  - 新增 `listServerLogs()` 函数
  - 所有方法增加 `source` 参数处理
- `web/src/views/SystemLogs.vue` - 增加 Tab 切换 UI
  - 新增 `logSource` 状态变量
  - 新增 Tab 组件切换应用日志/服务器日志
  - 修复 API 响应数据访问路径 (`res.data.files`)
- `web/src/api/index.js` - API 方法增加 source 参数

**相关代码位置**：
- 白名单定义: `internal/handler/system_log.go:NewSystemLogHandler()` 第27-44行
- 服务器日志列表: `internal/handler/system_log.go:listServerLogs()` 第173-250行
- 前端 Tab 切换: `web/src/views/SystemLogs.vue` 第13-24行

---

### 2025-12-13: 缓存管理功能完善

**需求描述**：
完善缓存管理页面，支持：
1. 按账号维度查看缓存（每个账号被哪些用户使用）
2. 按用户维度查看缓存（每个用户使用了哪些账号）
3. 缓存配置管理（各类TTL设置）
4. 用户并发控制

**实现方案**：

**缓存配置参数说明**：
| 参数 | 说明 | 默认值 |
|------|------|--------|
| `session_ttl` | 粘性会话TTL，会话绑定的过期时间 | 60分钟 |
| `session_renewal_ttl` | 会话续期阈值，剩余时间低于此值时自动续期 | 14分钟 |
| `unavailable_ttl` | 不可用标记TTL，账户临时不可用的标记时长 | 5分钟 |
| `concurrency_ttl` | 并发计数TTL，并发计数器的过期时间 | 5分钟 |
| `default_concurrency_max` | 默认最大并发数 | 5 |

**智能续期机制**：
当用户持续使用同一个会话时，系统检查会话剩余TTL，如果剩余时间低于 `session_renewal_ttl`，自动将TTL重置为 `session_ttl`。这样既避免了活跃用户会话中断，又避免了每次请求都续期的资源浪费。

**修改文件**：

后端：
- `internal/service/cache.go` - 缓存服务核心
  - `SessionBinding` 结构体 - 会话绑定信息
  - `AccountCacheInfo` 结构体 - 账号缓存聚合信息
  - `UserCacheInfo` 结构体 - 用户缓存聚合信息
  - `GetSessionBinding()` - 获取会话绑定（含智能续期）
  - `SetSessionBinding()` - 设置会话绑定
  - `ListAccountsWithCache()` - 按账号聚合缓存列表
  - `ListUsersWithCache()` - 按用户聚合缓存列表
  - `AcquireConcurrency()` / `ReleaseConcurrency()` - 账户并发控制
  - `GetUserConcurrency()` / `ResetUserConcurrency()` - 用户并发控制
- `internal/handler/cache.go` - 缓存管理API
  - `ListAccountsCache()` - 账号缓存列表接口
  - `ListUsersCache()` - 用户缓存列表接口
  - `GetCacheConfig()` / `UpdateCacheConfig()` - 缓存配置管理
  - `GetUserConcurrency()` / `ResetUserConcurrency()` - 用户并发管理
- `internal/middleware/user_concurrency.go` - 用户并发控制中间件
- `internal/handler/routes.go` - 添加新路由

前端：
- `web/src/api/index.js` - 添加缓存API
  - `getCacheAccounts()` - 获取账号缓存列表
  - `getCacheUsers()` - 获取用户缓存列表
- `web/src/views/Cache.vue` - 缓存管理页面重构
  - 缓存配置区域（4个TTL设置）
  - 账号缓存Tab（聚合视图 + 搜索 + 清除）
  - 用户缓存Tab（聚合视图 + 搜索 + 清除）

**API 接口**：

| 接口 | 方法 | 说明 |
|------|------|------|
| `/api/admin/cache/config` | GET | 获取缓存配置 |
| `/api/admin/cache/config` | PUT | 更新缓存配置 |
| `/api/admin/cache/accounts` | GET | 获取账号缓存列表（聚合） |
| `/api/admin/cache/users` | GET | 获取用户缓存列表（聚合） |
| `/api/admin/cache/sessions` | GET | 获取所有会话列表 |
| `/api/admin/cache/sessions/:id` | DELETE | 删除指定会话 |
| `/api/admin/cache/clear` | POST | 按类型清理缓存 |
| `/api/admin/users/:id/concurrency` | GET | 获取用户并发信息 |
| `/api/admin/users/:id/concurrency` | DELETE | 重置用户并发计数 |
| `/api/admin/accounts/:id/cache/concurrency` | GET | 获取账户并发信息 |
| `/api/admin/accounts/:id/cache/concurrency` | DELETE | 重置账户并发计数 |

**相关代码位置**：
- 会话绑定: `internal/service/cache.go:GetSessionBinding()` 第89-134行
- 智能续期: `internal/service/cache.go` 第130-132行
- 账号聚合: `internal/service/cache.go:ListAccountsWithCache()` 第660-704行
- 用户聚合: `internal/service/cache.go:ListUsersWithCache()` 第707-753行
- 用户并发中间件: `internal/middleware/user_concurrency.go`
- 前端缓存页面: `web/src/views/Cache.vue`

---

### 2025-12-11: 账户费用统计功能

**需求描述**：
账户管理页面需要显示每个账户消耗的总费用。

**实现方案**：
采用 MySQL 直写架构：
1. 写入：每次请求完成后，费用实时写入 MySQL
2. 查询：直接从 MySQL 查询账户费用

**修改文件**：
- `internal/service/usage.go` - 使用统计服务
  - `IncrementAccountCost()` - 增加账户费用（直接写 MySQL）
  - `GetAccountCost()` - 获取单个账户费用
  - `GetAccountsCost()` - 批量获取账户费用
- `internal/model/account.go` - 添加 `TotalCost` 字段
- `internal/repository/account.go` - 添加 `UpdateTotalCost()` 方法
- `internal/handler/proxy.go` - `recordUsage()` 调用 `IncrementAccountCost()`
- `web/src/views/Accounts.vue` - 添加"总费用"列

**相关代码位置**：
- 写入: `internal/handler/proxy.go:recordUsage()`
- 查询: `internal/handler/account.go:List()`

---

### 2025-12-10: 用户管理界面余额显示修复

**问题描述**：
- 用户管理页面的"余额"列需要删除
- "额度余额"和"订阅日余额"列始终显示 $0.00

**根本原因**：
`GetUserKeyBalances()` 方法中的 SQL 查询使用了 `JOIN api_keys ON user_package_id` 的方式关联数据，但数据库中所有 API Key 的 `user_package_id` 字段都是 NULL，导致 JOIN 操作返回空结果集。

**修复方案**：
1. **前端**: 删除 `Users.vue` 中的"余额"列（`row.balance`）
2. **后端**: 修改 `internal/repository/user.go` 中的 `GetUserKeyBalances()` 方法，直接从 `user_packages` 表按 `user_id` 查询，不再依赖与 `api_keys` 的关联

**修改文件**：
- `web/src/views/Users.vue` - 删除余额列
- `internal/repository/user.go` - 修改 SQL 查询逻辑

**相关代码位置**：
- 额度余额查询: `internal/repository/user.go:GetUserKeyBalances()` 第116-135行
- 订阅日余额查询: `internal/repository/user.go:GetUserKeyBalances()` 第137-161行

---

### 2025-12-10: 调度器缓存刷新修复

**问题描述**：
新添加的账户无法被代理使用，显示禁用状态。

**根本原因**：
调度器 (`scheduler.go`) 在启动时加载账户到内存缓存，但账户的增删改操作后没有刷新缓存。

**修复方案**：
在账户服务的 Create/Update/Delete 方法成功后调用 `scheduler.GetScheduler().Refresh()` 刷新缓存。

**修改文件**：
- `internal/service/account.go` - 添加 `Refresh()` 调用

**相关代码位置**：
- 创建后刷新: `internal/service/account.go:Create()` 第147行
- 更新后刷新: `internal/service/account.go:Update()` 第241行
- 删除后刷新: `internal/service/account.go:Delete()` 第254行

---

### 2025-12-10: 账户限流自动恢复

**问题描述**：
限流中的账户显示"即将恢复"，但一直没有实际恢复。

**根本原因**：
没有后台任务检查并自动恢复过期的限流账户。

**修复方案**：
1. 添加后台 goroutine 每分钟检查一次限流账户
2. 自动恢复 `rate_limit_reset_at` 已过期的账户

**修改文件**：
- `internal/proxy/scheduler/scheduler.go` - 添加 `startRateLimitRecoveryTask()` 后台任务
- `internal/repository/account.go` - 添加 `RecoverRateLimitedAccounts()` 方法

**相关代码位置**：
- 后台任务: `internal/proxy/scheduler/scheduler.go:startRateLimitRecoveryTask()` 第53-68行
- 恢复方法: `internal/repository/account.go:RecoverRateLimitedAccounts()` 第114-125行

---

### 2025-12-10: API Key 计费类型修复

**问题描述**：
1. 管理员创建 API Key 时，无论选择什么套餐类型，都只能创建额度类型
2. 管理员可以为同一用户创建多个相同计费类型的 Key

**根本原因**：
`AdminCreate()` 方法缺少 BillingType 字段赋值和同类型数量检查。

**修复方案**：
1. 添加 BillingType 提取、验证和赋值逻辑
2. 添加 `CountByUserIDAndBillingType()` 检查，每种计费类型限制1个

**修改文件**：
- `internal/service/api_key.go` - `AdminCreate()` 方法

**相关代码位置**：
- BillingType 处理: `internal/service/api_key.go:AdminCreate()` 第281-289行
- 数量限制检查: `internal/service/api_key.go:AdminCreate()` 第291-304行

---

### 2025-12-10: Claude 账户用量进度条

**问题描述**：
需要显示 Claude 账户的 5H、7D、7D-Sonnet 用量百分比进度条。

**实现方案**：
1. Account 模型添加 6 个字段存储利用率百分比和重置时间
2. 调用 `/api/oauth/usage` API 获取利用率数据
3. 前端显示进度条（绿/黄/红三色）

**修改文件**：
- `internal/model/account.go` - 添加利用率字段
- `internal/repository/account.go` - 添加 `UpdateClaudeUsage()` 方法
- `internal/handler/proxy.go` - 添加 `fetchClaudeOAuthUsage()` 和更新逻辑
- `web/src/views/Accounts.vue` - 添加进度条 UI

**相关代码位置**：
- 模型字段: `internal/model/account.go` 第96-102行
- 更新方法: `internal/repository/account.go:UpdateClaudeUsage()` 第143-196行
- OAuth API 调用: `internal/handler/proxy.go:fetchClaudeOAuthUsage()` 第786-814行
- 前端进度条: `web/src/views/Accounts.vue` 第106-168行, 879-937行

---

### 2025-12-10: RequestLogger 空指针崩溃修复

**问题描述**：
服务启动时崩溃，panic: nil pointer dereference。

**根本原因**：
`defaultRequestLogger` 在包加载时初始化，但此时��据库连接尚未建立。

**修复方案**：
使用 `sync.Once` 延迟初始化，在首次使用时才创建实例。

**修改文件**：
- `internal/handler/request_logger.go` - 改用懒加载模式

**相关代码位置**：
- 懒加载实现: `internal/handler/request_logger.go:GetRequestLogger()` 使用 `sync.Once`

---

### 2025-12-11: 请求日志添加IP记录显示

**问题描述**：
请求日志没有显示访问者的 IP 地址。

**现有状态**：
- 后端 `RequestLog` 模型已有 `RequestIP` 字段
- `proxy.go` 中使用 `c.ClientIP()` 正确记录 IP 到数据库

**缺失部分**：
- `UsageRecord` 结构体没有 `RequestIP` 字段
- 前端请求日志页面没有显示 IP 列

**修复方案**：
1. `UsageRecord` 结构体添加 `RequestIP` 字段
2. `RecordRequest` 方法填充 `RequestIP` 字段
3. 前端添加"请求IP"列

**修改文件**：
- `internal/service/usage.go` - `UsageRecord` 结构体添加 `RequestIP string`
- `internal/service/usage.go` - `RecordRequest()` 方法添加 `RequestIP: log.RequestIP`
- `web/src/views/RequestLogs.vue` - 添加请求IP列

**相关代码位置**：
- 结构体定义: `internal/service/usage.go:UsageRecord`
- 记录填充: `internal/service/usage.go:RecordRequest()`
- 前端显示: `web/src/views/RequestLogs.vue`

---

### 2025-12-14: 客户端过滤功能（简单/严格模式）

**需求描述**：
实现客户端过滤功能，支持两种验证模式：
- 简单模式（claude-relay 风格）：宽松验证
- 严格模式（AIProxyV2 风格）：完整验证

**实现方案**：

| 项目 | 简单模式 | 严格模式 |
|------|---------|---------|
| User-Agent | `claude-cli/版本号` 开头 | 完整格式 `(external, cli\|vscode\|...)` |
| 请求头 | x-app, anthropic-beta, anthropic-version | x-app, anthropic-version, x-stainless-os |
| System Prompt | Dice 相似度 ≥ 0.6 | Dice 相似度 ≥ 0.6 |
| metadata.user_id | 格式验证 | 格式验证 |

**修改文件**：

后端：
- `internal/model/client_filter.go` - 添加 `FilterMode` 常量和字段
- `internal/service/client_filter.go` - 根据模式选择验证规则
  - `matchClientType()` - 根据模式使用不同 UA 正则
  - `validateClaudeCodeRules()` - 新增：根据模式选择规则集
- `internal/repository/client_filter.go` - 支持 `filter_mode` 字段保存

前端：
- `web/src/views/ClientFilter.vue` - 简化界面
  - 主开关
  - 允许的客户端列表（点击切换）
  - 验证模式选择（简单/严格）
  - 测试功能

**相关代码位置**：
- 模式常量: `internal/model/client_filter.go:37-40`
- UA 匹配: `internal/service/client_filter.go:matchClientType()` 第239-274行
- 规则验证: `internal/service/client_filter.go:validateClaudeCodeRules()` 第320-458行

---

### 2025-12-14: gzip 响应解压修复

**问题描述**：
502 错误 `parse response: invalid character '\x1f' looking for beginning of value`

**根本原因**：
上游 API 返回 gzip 压缩的响应，但代码直接 JSON 解析未解压的数据。`\x1f` 是 gzip magic bytes 的第一个字节。

**修复方案**：
1. 添加 `ReadResponseBody()` 辅助函数，自动检测和解压 gzip
2. 过滤 `Accept-Encoding` 请求头，避免请求 gzip 响应

**修改文件**：
- `internal/proxy/adapter/http_client.go` - 新增 `ReadResponseBody()` 函数
- `internal/proxy/adapter/claude.go` - 使用 `ReadResponseBody()`，过滤 `accept-encoding` 头
- `internal/proxy/adapter/openai.go` - 使用 `ReadResponseBody()`
- `internal/proxy/adapter/azure.go` - 使用 `ReadResponseBody()`
- `internal/proxy/adapter/gemini.go` - 使用 `ReadResponseBody()`
- `internal/proxy/adapter/bedrock.go` - 使用 `ReadResponseBody()`
- `internal/proxy/adapter/claude_ccr.go` - 使用 `ReadResponseBody()`

**相关代码位置**：
- gzip 解压: `internal/proxy/adapter/http_client.go:ReadResponseBody()` 第62-116行
- 头过滤: `internal/proxy/adapter/claude.go:setHeaders()` 第222行

### 2025-12-15: 系统监控模块

**需求**: 新增系统监控页面，显示系统资源、数据库状态、账号统计、用户统计、今日使用量

**新增文件**:
- `internal/service/system_monitor.go` - 监控服务（聚合各项统计数据）
- `internal/handler/system_monitor.go` - 监控 API 接口

**修改文件**:
- `internal/handler/routes.go` - 添加 `/api/admin/monitor` 路由组
- `web/src/views/SystemMonitor.vue` - 监控页面
- `web/src/router/index.js` - 添加前端路由
- `web/src/layouts/MainLayout.vue` - 添加菜单项
- `web/src/api/index.js` - 添加监控 API
- `go.mod` - 新增 `github.com/shirou/gopsutil/v3` 依赖

**监控指标**:
| 分类 | 指标 |
|------|------|
| 系统资源 | CPU、内存、磁盘 |
| 缓存 | 会话数量、并发数 |
| MySQL | 表数量、数据大小 |
| 账号 | 总数、正常、限流、无效 |
| 用户 | 总数、活跃、新增 |
| 今日使用 | 消费、Token、请求数 |

**相关代码位置**：
- 监控服务: `internal/service/system_monitor.go`
- 监控接口: `internal/handler/system_monitor.go`
- 前端页面: `web/src/views/SystemMonitor.vue`

---

### 2025-12-15: 系统日志查看功能

**需求**: 在 Web 界面查看服务器端的所有日志文件

**新增文件**:
- `internal/handler/system_log.go` - 系统日志 API（文件列表、读取、tail、下载、删除）
- `web/src/views/SystemLogs.vue` - 系统日志查看页面

**修改文件**:
- `internal/handler/routes.go` - 添加 `/api/admin/system-logs` 路由组
- `web/src/router/index.js` - 添加前端路由
- `web/src/layouts/MainLayout.vue` - 添加菜单项
- `web/src/api/index.js` - 添加系统日志 API

**功能特点**:
| 功能 | 说明 |
|------|------|
| 文件列表 | 按分类、日期筛选日志文件 |
| 分页读取 | 支持大文件分页显示 |
| 关键词搜索 | 按关键词过滤日志内容 |
| 正序/倒序 | 切换日志显示顺序 |
| 实时 tail | 查看最新日志（类似 tail 命令） |
| 下载/删除 | 管理日志文件 |

**API 接口**:
| 接口 | 方法 | 说明 |
|------|------|------|
| `/api/admin/system-logs/files` | GET | 获取日志文件列表 |
| `/api/admin/system-logs/read` | GET | 分页读取日志内容 |
| `/api/admin/system-logs/tail` | GET | 获取日志末尾内容 |
| `/api/admin/system-logs/download` | GET | 下载日志文件 |
| `/api/admin/system-logs/file` | DELETE | 删除日志文件 |

**相关代码位置**：
- 日志 Handler: `internal/handler/system_log.go`
- 前端页面: `web/src/views/SystemLogs.vue`

---

## 版本信息

- Go: 1.21+
- Vue: 3.x
- Element Plus: 2.x
- GORM: 2.x
- Gin: 1.x
