# 故障排查手册

> 最后更新：2025-12-24
> 遇到问题直接查，立刻知道怎么处理

---

## 快速导航

| 问题类型 | 跳转 |
|----------|------|
| 启动失败 | [启动问题](#一启动问题) |
| 代理请求失败 | [代理问题](#二代理问题) |
| 数据不对 | [数据问题](#三数据问题) |
| 页面显示异常 | [前端问题](#四前端问题) |
| 缓存/会话问题 | [缓存问题](#五缓存问题) |
| 客户端被拒绝 | [客户端过滤问题](#六客户端过滤问题) |
| 账号被自动禁用 | [健康检查问题](#七健康检查问题) |
| 看错误信息 | [按错误信息分类](#按错误信息分类) |

---

## 按现象分类

### 一、启动问题

| 现象 | 原因 | 解决方法 |
|------|------|----------|
| 端口 8080 被占用 | 其他进程占用 | `lsof -i:8080` → `kill <PID>` |
| panic: nil pointer | 初始化顺序问题 | 检查是否数据库未连接就访问了 repo |
| 数据库连接失败 | 配置错误/MySQL未启动 | 检查 `configs/config.yaml` 中 mysql 配置 |
| 表不存在 | 迁移未执行 | 重启服务自动迁移，或检查 `migrate.go` |
| **SSH断开后服务停止** | nohup启动的进程随会话终止 | 使用 systemd 服务管理，见下方说明 |

#### SSH 断开后服务停止的解决方案

**问题原因**: 用 `nohup ./aiproxy &` 启动的进程，在 SSH 会话断开时会被 systemd 的 session scope 清理掉。

**解决方案**: 使用 systemd 服务管理，配置文件 `/etc/systemd/system/aiproxy.service`：

```ini
[Unit]
Description=Go-AIProxy Service
After=network.target mysql.service

[Service]
Type=simple
User=root
WorkingDirectory=/root/go-aiproxy
ExecStart=/root/go-aiproxy/aiproxy
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

**启用命令**:
```bash
systemctl daemon-reload
systemctl enable aiproxy
systemctl start aiproxy
```

**详细记录**: [BUG处理/2025-12-17-SSH断开后服务停止问题.md](BUG处理/2025-12-17-SSH断开后服务停止问题.md)

### 二、代理问题

| 现象 | 原因 | 解决方法 |
|------|------|----------|
| 请求超时 | 上游响应慢 | 增加 `proxy.timeout` 配置 |
| 401 Unauthorized | API Key 无效/过期 | 查 `api_keys` 表状态 |
| 403 Forbidden | 无权限/套餐限制 | 检查用户套餐、模型权限 |
| 账户不可用 | 无启用账户/全部限流 | 查 `accounts` 表 enabled 和 rate_limit_reset_at |
| 新账户无法使用 | 调度器缓存未刷新 | 重启服务或调用 `scheduler.Refresh()` |
| 限流不恢复 | 恢复任务未执行 | 检查 `startRateLimitRecoveryTask()` 是否启动 |
| /responses 返回 503 | 无可用账户 | 检查是否有 `openai-responses` 或 `openai` 类型账户 |

### 三、数据问题

| 现象 | 原因 | 解决方法 | 相关文件 |
|------|------|----------|----------|
| 套餐余额不扣减 | `IncrementUsage()` 未调用 | 检查 `proxy.go` 的 `recordUsage()` | `handler/proxy.go` |
| 费用显示 $0 | MySQL 无数据 | 检查 `IncrementCost()` 调用 | `service/usage.go` |
| 账户费用为 0 | `IncrementAccountCost()` 未调用 | 检查 `recordUsage()` | `handler/proxy.go` |
| 使用统计不准 | MySQL 数据未更新 | 检查 `daily_usages` 表数据 | `repository/daily_usage.go` |

### 四、前端问题

| 现象 | 原因 | 解决方法 |
|------|------|----------|
| 页面白屏 | JS 错误 | F12 查看控制台报错 |
| 接口 404 | 路由未注册/路径错误 | 检查 `handler/routes.go` |
| 数据不刷新 | 缓存/未重新请求 | 手动刷新或检查 API 调用 |
| 列表为空 | API 返回空/分页问题 | 检查 API 响应和参数 |

### 五、缓存问题

| 现象 | 原因 | 解决方法 | 相关文件 |
|------|------|----------|----------|
| 会话不粘性 | TTL 太短/会话ID变化 | 检查 `session_ttl` 配置和客户端会话ID | `service/cache.go` |
| 并发数不准 | 计数器泄漏 | 等待 `concurrency_ttl` 过期或重置 | `service/cache.go` |
| 缓存页面无数据 | 无活跃会话 | 正常情况，使用代理后才有数据 | `views/Cache.vue` |
| 账号被标记不可用 | 上游返回错误 | 等待 `unavailable_ttl` 过期或手动清除 | `service/cache.go` |
| OpenAI Responses 请求路由到不同账户 | 未使用会话粘性方法 | 确保使用 `SelectAccountByTypeWithSession()` | `scheduler/scheduler.go` |

#### OpenAI Responses 会话粘性排查

会话绑定存储在内存缓存中，重启服务会丢失。如需排查：
1. 检查服务日志中的会话绑定记录
2. 通过管理界面「缓存管理」查看会话列表
3. 如需重新绑定，清除该 API Key 的会话缓存

### 六、客户端过滤问题

| 现象 | 原因 | 解决方法 | 相关文件 |
|------|------|----------|----------|
| 所有请求被拒绝 | 过滤已启用但无允许客户端 | 添加允许的客户端类型 | `service/client_filter.go` |
| 简单模式不通过 | UA 不以 `claude-cli/` 开头 | 检查 User-Agent 格式 | `service/client_filter.go` |
| 严格模式不通过 | UA/Headers/Body 不符合 | 检查完整验证规则 | `service/client_filter.go` |
| 502 + `\x1f` 错误 | gzip 响应未解压 | 使用 `ReadResponseBody()` | `adapter/http_client.go` |

### 七、健康检查问题

| 现象 | 原因 | 解决方法 | 相关文件 |
|------|------|----------|----------|
| 账号被自动禁用 | 健康检查连续失败达到阈值 | 检查账号认证信息是否有效，手动重新启用 | `service/health_check.go` |
| OAuth Token 失效 | Token 过期或被撤销 | 重新进行 OAuth 授权获取新 Token | `service/health_check.go` |
| SessionKey 失效 | 会话过期 | 重新登录获取新 SessionKey | `service/health_check.go` |
| ChatGPT 账号验证失败 | OAuth Token 过期 | 重新获取 ChatGPT OAuth Token | `service/health_check.go` |
| 健康检查未执行 | 功能未启用 | 在系统设置中启用健康检查 | `service/config.go` |

#### 健康检查排查

**查看健康检查状态**：
```bash
# 查看健康检查相关日志
grep "health_check" logs/app.log | tail -50

# 查看账号连续错误次数
mysql -e "SELECT id, name, type, enabled, consecutive_error_count FROM accounts WHERE consecutive_error_count > 0;"
```

**常见问题**：

1. **Claude OAuth 验证失败**：
   - 端点：`https://api.anthropic.com/api/oauth/usage`
   - 检查 `access_token` 是否过期
   - 需要重新进行 OAuth 授权

2. **Claude SessionKey 验证失败**：
   - 端点：`https://claude.ai/api/organizations`
   - 检查 `session_key` 是否过期
   - 需要重新登录 Claude 获取新 SessionKey

3. **ChatGPT OAuth 验证失败**：
   - 端点：`https://chatgpt.com/backend-api/accounts/check/v4-2023-04-27`
   - 检查 `access_token` 或 `session_key` 是否为有效的 JWT Token
   - 需要重新获取 ChatGPT OAuth Token

4. **Gemini OAuth 验证失败**：
   - 端点：`https://generativelanguage.googleapis.com/v1beta/models`
   - 检查 OAuth Token 是否过期
   - 需要重新进行 Google OAuth 授权

**手动重置连续错误计数**：
```sql
-- 重置单个账号
UPDATE accounts SET consecutive_error_count = 0 WHERE id = 1;

-- 重置并启用账号
UPDATE accounts SET consecutive_error_count = 0, enabled = true WHERE id = 1;

-- 重置所有账号
UPDATE accounts SET consecutive_error_count = 0;
```

**健康检查配置**：
```sql
-- 查看配置
SELECT * FROM system_configs WHERE key LIKE 'account_%';

-- 启用健康检查
INSERT INTO system_configs (key, value) VALUES ('account_health_check_enabled', 'true')
ON DUPLICATE KEY UPDATE value = 'true';

-- 设置检查间隔（分钟）
INSERT INTO system_configs (key, value) VALUES ('account_health_check_interval', '5')
ON DUPLICATE KEY UPDATE value = '5';

-- 设置错误阈值
INSERT INTO system_configs (key, value) VALUES ('account_error_threshold', '5')
ON DUPLICATE KEY UPDATE value = '5';
```

---

## 按错误信息分类

### "invalid token" / "token expired"
- **文件**: `internal/middleware/jwt.go`
- **原因**: JWT Token 过期或格式错误
- **解决**:
  1. 重新登录获取新 Token
  2. 检查 `jwt.expire_hours` 配置是否太短

### "account not available"
- **文件**: `internal/proxy/scheduler/scheduler.go`
- **原因**: 没有可用的上游账户
- **解决**:
  1. 检查 `accounts` 表是否有 `enabled=true` 的账户
  2. 检查是否全部被限流 (`rate_limit_reset_at` 不为空)
  3. 检查账户类型是否匹配请求的平台

### "rate limit exceeded"
- **文件**: `internal/middleware/api_key.go`
- **原因**: API Key 请求频率超限
- **解决**:
  1. 等待限制解除
  2. 调整 `api_keys.rate_limit` 配置

### "quota exceeded" / "daily limit exceeded"
- **文件**: `internal/model/package.go`
- **原因**: 套餐额度用完
- **解决**:
  1. 查看用户套餐使用情况
  2. 增加额度或重置使用量

### "model not allowed"
- **文件**: `internal/middleware/api_key.go`
- **原因**: API Key 或套餐不允许使用该模型
- **解决**:
  1. 检查 `api_keys.allowed_models`
  2. 检查 `user_packages.allowed_models`

### "invalid character '\x1f' looking for beginning of value"
- **文件**: `internal/proxy/adapter/*.go`
- **原因**: 上游返回 gzip 压缩响应，未正确解压
- **说明**: `\x1f\x8b` 是 gzip 文件的魔术字节
- **解决**:
  1. 确保使用 `ReadResponseBody()` 处理响应
  2. 检查是否过滤了 `accept-encoding` 请求头

### "client not allowed" / "验证失败"
- **文件**: `internal/service/client_filter.go`
- **原因**: 客户端过滤功能已启用，请求未通过验证
- **解决**:
  1. 检查过滤模式（简单/严格）
  2. 简单模式：确保 User-Agent 以 `claude-cli/版本` 开头
  3. 严格模式：确保完整 UA 格式、必需请求头、System Prompt
  4. 临时关闭过滤：设置 `filter_enabled = false`

### "no available account" (503 on /responses)
- **文件**: `internal/handler/openai_responses.go`
- **原因**: 没有可用的 OpenAI Responses 账户
- **解决**:
  1. 检查是否有 `openai-responses` 或 `openai` 类型的账户
  2. 确保账户 `enabled = true` 且 `status = 'valid'`
  3. 第三方 OpenAI API 也支持 `/responses` 端点，类型为 `openai`
  4. 检查账户的 `rate_limit_reset_at` 是否已过期

**排查命令**：
```sql
-- 查看可用的 OpenAI Responses 账户
SELECT id, name, type, enabled, status, rate_limit_reset_at
FROM accounts
WHERE type IN ('openai-responses', 'openai')
  AND enabled = true
  AND status = 'valid'
  AND (rate_limit_reset_at IS NULL OR rate_limit_reset_at < NOW());
```

**详细记录**: [BUG处理/2025-12-19-OpenAI-Responses接口账户类型选择修复.md](BUG处理/2025-12-19-OpenAI-Responses接口账户类型选择修复.md)

---

## 日志查看指南

### 查看服务日志
```bash
# 实时查看日志
tail -f logs/app.log

# 搜索错误
grep -i "error" logs/app.log | tail -50

# 搜索特定用户
grep "user_id\":1" logs/app.log | tail -20

# 搜索特定请求
grep "request_id" logs/app.log | tail -20
```

### 查看数据库数据
```sql
-- 用户信息
SELECT id, username, role, status, price_rate FROM users WHERE id = 1;

-- 用户套餐及使用量
SELECT id, user_id, name, type, status,
       daily_quota, daily_used,
       weekly_quota, weekly_used,
       monthly_quota, monthly_used,
       quota_total, quota_used
FROM user_packages WHERE user_id = 1;

-- 账户状态
SELECT id, name, type, enabled,
       rate_limit_reset_at, total_cost,
       current_load, daily_requests
FROM accounts ORDER BY id;

-- API Key 状态
SELECT id, user_id, name, billing_type, status,
       request_count, cost_used
FROM api_keys WHERE user_id = 1;

-- 最近请求日志
SELECT id, user_id, model, status_code,
       input_tokens, output_tokens, cost,
       created_at
FROM request_logs
ORDER BY created_at DESC LIMIT 20;

-- 每日使用汇总
SELECT user_id, date, model, request_count, total_tokens, total_cost
FROM daily_usages
WHERE user_id = 1
ORDER BY date DESC LIMIT 10;
```

### 查看内存缓存状态
通过管理界面「缓存管理」页面查看：
- 会话列表及绑定状态
- 账号并发数
- 用户并发数
- 不可用账户列表

---

## 常见操作速查

### 重置用户套餐使用量
```sql
-- 重置订阅套餐的周期使用量
UPDATE user_packages
SET daily_used = 0, weekly_used = 0, monthly_used = 0,
    last_reset_day = CURDATE(),
    last_reset_week = YEARWEEK(CURDATE()),
    last_reset_month = DATE_FORMAT(CURDATE(), '%Y-%m')
WHERE user_id = 1 AND type = 'subscription';

-- 重置额度套餐的已用量
UPDATE user_packages
SET quota_used = 0
WHERE user_id = 1 AND type = 'quota';
```

### 清除账户限流状态
```sql
-- 清除单个账户
UPDATE accounts SET rate_limit_reset_at = NULL WHERE id = 1;

-- 清除所有账户
UPDATE accounts SET rate_limit_reset_at = NULL WHERE rate_limit_reset_at IS NOT NULL;
```

### 启用/禁用账户
```sql
-- 启用账户
UPDATE accounts SET enabled = true WHERE id = 1;

-- 禁用账户
UPDATE accounts SET enabled = false WHERE id = 1;
```

### 刷新调度器缓存
```go
// 在代码中调用（账户增删改后自动调用）
scheduler.GetScheduler().Refresh()
```
或者直接重启服务。

### 清除内存缓存
通过管理界面操作（推荐）：
1. 访问「缓存管理」页面
2. 账号缓存Tab → 清除单个或全部
3. 用户缓存Tab → 清除单个或全部

注意：内存缓存会在服务重启后自动清空。

---

## 问题排查流程

### 代理请求失败排查流程
```
1. 检查 API Key 是否有效
   └── SELECT * FROM api_keys WHERE key_hash = SHA2('your-key', 256);

2. 检查用户套餐
   └── SELECT * FROM user_packages WHERE user_id = X AND status = 'active';

3. 检查账户可用性
   └── SELECT * FROM accounts WHERE type = 'xxx' AND enabled = true AND rate_limit_reset_at IS NULL;

4. 检查请求日志
   └── SELECT * FROM request_logs WHERE user_id = X ORDER BY created_at DESC LIMIT 10;

5. 检查服务日志
   └── grep "error" logs/app.log | tail -50
```

### 费用不对排查流程
```
1. 检查 MySQL 数据
   └── SELECT SUM(cost) FROM request_logs WHERE user_id = X;

2. 检查每日汇总表
   └── SELECT * FROM daily_usages WHERE user_id = X ORDER BY date DESC LIMIT 10;

3. 检查账户费用
   └── SELECT id, name, total_cost FROM accounts;

4. 对比 request_logs 和 daily_usages 数据是否一致
```

---

## 相关文档

- [代码索引](代码索引.md) - 代码位置速查
- [功能模块索引](功能模块索引.md) - 功能配置速查
- [BUG处理/](BUG处理/) - 历史问题修复记录
- [开发日志/](开发日志/) - 开发变更记录
